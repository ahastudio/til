- [2016년 이상한모임 Advent Calendar](https://j.mp/3vfFcIf)
- 이전 글: 12월 2일, [초심자가 타입 시스템에 대해 오해하는 몇 가지](https://j.mp/2gMvjfv)
- 다음 글: 12월 4일, [서버리스 일 년간 약 판 회고](https://j.mp/2gvh2TJ)

---

# 2016-12-03 - TDD FAQ

## 저자
[@ahastudio](https://j.mp/1ea27KW) - 코딩의 신[神]. 게임과 웹 등 다양한 분야를 떠돌았고, 최근엔 Lean Startup과 Machine Learning을 공부하면서 가르치고 있습니다.

## 시작하며
2016년에도 [이상한모임 대림절 달력](https://j.mp/3vfFcIf)에 참여하게 되었습니다. 계속 몸 상태가 안 좋아서 또 급히 쓰게 됐네요.

무슨 글을 쓸까 고민하다가 뻔한 내용을 재탕하기로 했습니다. 기초적인 내용도 도움이 될 분이 계실 거라는 기대가 빗나가지 않길 바랍니다.

TDD(Test Driven Development, 테스트 주도 개발)에 관한 자주 묻는 질문 몇 가지에 간단히 답하면서, TDD를 통해서 “뭘 얻을 수 있는지” 생각하고 실무에서도 적극 활용할 수 있는 기회가 되면 좋겠습니다.

## 단위 테스트와 TDD는 뭐가 다르죠?

단위 테스트는 구현에 대한 테스트를 의미합니다. TDD는 자동화된 단위 테스트 코드를 먼저 작성함으로써 테스트가 개발을 이끌어나가도록 하는 방식입니다.

간단한 JavaScript 코드를 예로 들어볼까요?

```javscript
Number.prototype.square = function () {
    return this * this;
};
```

제곱을 구하는 단순한 코드입니다. 수동으로 하는 단위 테스트는 다음과 같이 할 수 있습니다.

```javascript
console.log((1).square()); // 1이 출력되는지 눈으로 확인한다.
console.log((2).square()); // 4가 출력되는지 눈으로 확인한다.
console.log((3).square()); // 9가 출력되는지 눈으로 확인한다.
// ...반복...
```

자동화된 단위 테스트 코드는 다음과 같습니다.

```javascript
function assertEqual(e, a) {
    if (e !== a) {
        throw `Test Fail!\nExpected: ${e}\nActual: ${a}`;
    }
};

assertEqual(1, (1).square());
assertEqual(4, (2).square());
assertEqual(9, (3).square());
```

자동화된 단위 테스트는 항상 우리가 기대한 올바른 결과가 나오는 걸 전제로 합니다. 그렇기 때문에 대부분의 테스팅 프레임웍은 몇 개의 테스트가 얼마나 걸려서 실행됐다 하는 간단한 정보만 노출합니다. 만약 테스트가 실패한 경우엔 최대한 유용한 피드백을 주기 위해서 노력합니다.

TDD는 인터페이스와 예제, 기대하는 결과를 먼저 작성하는 걸로 시작합니다. 단위 테스트 코드를 작성한다는 건 이미 설계가 어느 정도 된 상태, 즉 인터페이스와 예제가 만나는 지점을 묘사할 수 있는 상태를 전제로 합니다. 설계가 완벽할 수도 있고, 완전히 뜯어고치는 걸 전제로 구상만 한 상태일 수도 있습니다. 어떤 상황이든 상관 없습니다.

## TDD의 간단한 예를 보여주세요.

제곱을 구하는 프로그램을 JavaScript로 작성해 봅시다.

```javascript
function assertEqual(e, a) {
    if (e !== a) {
        throw `Test Fail!\nExpected: ${e}\nActual: ${a}`;
    }
};
// 여기까지는 바로 위에서 다룬 코드죠?

// 여기서는 조금 다른 인터페이스로 시작해 봅시다.
assertEqual(1, Math.square(1));
```

맨 처음엔 `Math.square`가 없다고 에러를 냅니다. 재빨리 다음 코드를 작성합니다.

```javascript
Math.square = (x) => {
    return 1;
};

assertEqual(1, Math.square(1));
```

또 다른 테스트 코드를 더합니다.

```javascript
assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
```

실패하는 걸 볼 수 있고, 재빨리 다른 코드를 더합니다.

```javascript
Math.square = (x) => {
    if (x === 2) {
        return 4;
    }
    return 1;
};

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
```

“의도”를 드러냅니다. `4`는 어떤 의미죠? `2`의 제곱, 즉 `2 * 2`죠.

```javascript
Math.square = (x) => {
    if (x === 2) {
        return 2 * 2;
    }
    return 1;
};

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
```

`2`는 어디서 왔죠? 우리가 함수를 호출할 때 넘겨준 거죠.

```javascript
Math.square = (x) => {
    if (x === 2) {
        return x * x;
    }
    return 1;
};

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
```

혹시 `1`일 때도 동일하게 적용 가능할까요? `1`을 넣었을 때 `1`이 나온 이유도 살펴보죠.

```javascript
Math.square = (x) => {
    if (x === 2) {
        return x * x;
    }
    if (x === 1) {
        return 1 * 1;
    }
};

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
```

`1`도 우리가 넘겨준 거였네요.

```javascript
Math.square = (x) => {
    if (x === 2) {
        return x * x;
    }
    if (x === 1) {
        return x * x;
    }
};

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
```

공통된 부분을 합치고(중복을 제거하고), 다른 예제도 통과하는지 확인합니다.

```javascript
Math.square = (x) => x * x;

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
assertEqual(9, Math.square(3));
```

`square`를 `Math`란 네임스페이스 안에 묶어주지 말고, 숫자(`Number`)에 공통으로 적용시켜봅시다.

```javascript
assertEqual(1, (1).square());
// 만약 그냥 1.square라고 하면 1.234 같은 숫자로 오해한 문법 에러가 납니다.
// 변수에 넣어서 쓰거나 괄호를 쳐서 마침표가 오해받는 일이 없도록 합니다.
```

`square`란 함수가 없다고 하니 재빨리 더합니다.

```javascript
Math.square = (x) => x * x;

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
assertEqual(9, Math.square(3));

Number.prototype.square = function () {
    return Math.square(this);
}

assertEqual(1, (1).square());
```

리팩터링([Inline Method](https://j.mp/2gMziIG))!


```javascript
Number.prototype.square = function () {
    return this * this;
}

assertEqual(1, (1).square());
assertEqual(4, (2).square());
assertEqual(9, (3).square());
```

코드를 반복해서 적었기 때문에 길어 보이지만, 실제로 하면 순식간에 진행 가능합니다. 우리의 사고 과정을 작은 단계로 나누고, 각 단계를 코드로 적고 검증하면서 진행할 수 있죠. “이건 대단히 복잡한 일이야”라고 하면서 한번에 커다랗게 쓰는 것 밖에 할 수 없는 사람과, “이건 대단히 복잡하니 작게 나눠서 진행하겠어”라고 말하고 노력하는 사람은 어떤 점에서 다를까요?

## 작업을 작게 나눠서 테스트를 나중에 하면 안 되나요?

작업을 작게 나눌 수 있다면 테스트 코드를 나중에 적는 것도 가능합니다. 다만, 확신의 정도가 조금 다릅니다. 우리가 확실히 실패하는 상황에서 성공하는 상황으로 전환했는지, 아니면 그냥 뭔가 잘못해서 우연히 성공하는 상태에 코드를 더한 건지 알아채기 어렵습니다.

TDD는 테스트 코드를 먼저 작성하는 것이 전부가 아닙니다. 테스트 코드를 작성하고, 테스트가 실패하는 걸 확인합니다. 제 경우엔 테스트가 확실히 실패하는 걸 확인하지 않고 넘어갔다가 나중에서야 사소한 실수(하지만 이런 게 항상 큰 문제를 일으키죠)를 발견한 경험이 적지 않습니다. 테스트 케이스를 꼼꼼히 검토함으로써 이 문제를 해결할 수 있지만, 이런 문제를 가장 빨리 확인할 수 있는 건 “나중”이 아니라 “바로 지금”이죠. 나중에 발견할수록 비용은 점점 커지기 마련입니다.

## 뭘 테스트해야 할지 모르겠어요.

책이 있다면 책장을 넘기면서 책을 보는 게 어렵지 않습니다. 아무 것도 없는 상태에서 책장을 넘기는 행위를 경험하는 건 대단히 어렵죠. 테스트 코드를 먼저 작성하는 건 자연스럽지 않습니다.

우리가 하는 일은 항상 무에서 유를 창조하는 일입니다. 제품을, 서비스를 만든다는 건 기존의 경험을 참고해서 새로운 걸 만들어내는 일이죠. 만약 기존과 동일하다면, 기존의 경험을 그대로 활용하면 됩니다. 그렇지 않다면 재빨리 새로운 형태를 찾아야 합니다.

여기 몇 가지 해법이 있습니다. 간단한 프로토타입을 만들고 어떤 가능성을 보게 됐을 때 프로토타입 코드를 모두 지우고 제대로 된 코드를 TDD로 진행할 수 있습니다. 버전 컨트롤(e.g. Git)과 브랜치 기능을 활용하면 제품에 가까운 실험을 재빨리 진행할 수 있습니다.

또 다른 방법은 더 작은 단위, 또는 더 큰 단위로 시도하는 겁니다. 책장을 넘기는 작업에 집중하지 않고 책을 본다는 행위에 집중하거나, 글자 하나를 본다는 작업에 집중하다가 한꺼번에 너무 많은 글자가 나오는 게 아닌가 하는 문제에 다다랐을 때 페이지 분할 및 페이지 전환 이슈에 집중해 책장 넘김을 유도하는 방법이 있죠.

“내”가 어떤 사고에 더 익숙한지 알면 어떤 접근을 해야 할지 더 빨리 결정할 수 있습니다. 짝 프로그래밍을 한다면, “우리”가 어떤 시도를 했을 때 좋았는지 실험하고 배우고 활용할 수 있습니다. 각자 고민하고, 그 결과를 합치는 방법도 효과적입니다.

중요한 건 어떻게든 첫 발을 내딛는 겁니다. 창조보다 비판과 개선이 훨씬 쉬운 법이니까요. 테스트 코드가 있다면, 우리는 리팩터링을 통해 더 나아질 수 있습니다.

## 그래도 테스트 코드를 쓰는 건 여전히 어려워요.

아마도 “테스트”라는 말이 가지는 고정관념 때문일 수 있습니다. 그냥 마구잡이로 실행해 보고 우연히 버그를 찾아내는 그런 일 말이죠(테스트 케이스를 만들고 체계적으로 품질 관리를 하는 테스터가 보면 화낼 수 있겠네요).

정확히 뭘 만들어야 하는지 To Do 목록을 만들어 보세요. 분명한 스펙이 정해지지 않았다면 이 일이 어려울 수 있습니다. 이건 분석/설계 단계가 미흡한 게 원인일 수도 있고, 그냥 개발자가 직접 결정해야 하는 문제일 수도 있습니다. 정확히 뭐가 원인일지 추측해 보세요.

스펙이 명확하다면 그걸 어떻게 사용할지 간단한 예제 코드를 작성해 보세요.

```javascript
const human = new Human({
    name: '강동원',
});

human.on('talk', function() {
    return `나는 ${this.alias()}다.`;
});

assertEqual('강동원: 나는 강참치다.', human.talk());
```

이제 구현하면 되겠죠?

```javascript
class Human {
    constructor({ name }) {
        this.name = options.name;
        this.alias = () => this.name.replace('동원', '참치');
    }

    on(event, callback) {
        this[event] = () => `${this.name}: ${callback.apply(this)}`;
    }
}

// 일부러 alias와 on을 다르게 구현했습니다. 둘은 어떻게 다를까요? :)
```

여기서는 한번에 만들었는데, 실제로는 각 단계를 나눠서 진행할 수 있습니다. 직접 해보시면 더 많은 테스트 코드를 작성하고 예외 상황 등을 포함해 더 많은 예제를 작성하고 결정하고 구현하는 자신을 발견하실 수 있을 겁니다(e.g. 이름이 “강동원x강동원”이라면? 이름이 `null`이라면?).

## private 메서드를 테스트하고 싶어요.

항상 나오는 단골 질문입니다. 극단적인 답을 하나 내놓는다면 다음과 같습니다.

> private 메서드의 존재 자체가 SRP 위반을 경고합니다.

좀더 일반적인 답은 다음과 같습니다.

> 헬퍼 메서드라면 public 메서드를 테스트할 때 함께 테스트하게 됩니다. 만약 그렇지 않다면 다른 클래스의 public 메서드로 분리하고 해당 인스턴스를 참조하세요.

다른 클래스로 분리하고 인스턴스를 참조하면 가짜 구현(Mock Object 등)을 활용하기 좋습니다. 참조를 통한 재활용을 염두에 두면 훨씬 유연한 구조로 설계/리팩터링할 수 있습니다.

일반적으론, SOLID 원칙을 따르면 테스트하기 쉽습니다. 뭔가 테스트하기 애매한 상황을 만난다면, 지금이 바로 미래를 위해 설계를 개선할 절호의 기회인 거죠. 어떤 방향이 옳은지 알기 어렵다면 버전 컨트롤의 브랜치 기능을 활용하고, 동료 개발자와 함께 고민하면 좋습니다(또는 “[개발자, 한 달에 책 한 권 읽기](http://j.mp/2H2MNnw)” 모임에 참석하거나 아샬에게 문의하는 방법도 있습니다...는 홍보).

## 협력 객체가 너무 많아서 테스트 코드가 너무 길어요.

서비스 객체를 만드는데 너무 많은 Respository를 쓴다거나, 참조하는 객체가 굉장히 많은 상황이 생길 수 있습니다. Mock Object를 적극적으로 활용하고 있다면 가짜 구현을 잡아주는 것도 엄청난 일입니다.

우리가 시스템을 분할/설계하는 건 계층구조를 만드는 겁니다. 거칠게 요약하면 모든 객체지향 개발은 레이어를 쌓는 작업입니다. 레이어가 너무 깊어서 이해하기 어려워도 문제겠지만, 너무 레이어가 없어서 한번에 협력해야 하는 객체가 많아도 문제입니다.

UML을 활용하고 있다면, 클래스 다이어그램 외에 시퀀스 다이어그램과 협력 다이어그램을 그려볼 것을 권합니다. 뭔가 복잡하게 그려진다면, 분명히 더 쉽게 그릴 수 있는 방법이 있을 겁니다. 다양한 디자인 패턴을 활용해 보세요(놀랍게도, 12월 [개발자, 한 달에 책 한 권 읽기](https://j.mp/2H2MNnw)에선 “GoF의 디자인 패턴”을 함께 읽습니다…는 홍보).

## 실무에서 TDD를 하나요?

네, 항상 합니다.

테스트를 먼저 작성했는지는 코드 리뷰 때 금방 드러납니다. 뭔가 놓치는 부분은 테스트 코드를 먼저 작성하지 않아서(또는 먼저 고민하지 않아서) 생기는 문제더군요. 작업을 작게 나누고, 해당 작업을 겨냥한 테스트를 먼저 정의하고 진행해야 진짜로 어떤 작업을 했는지 명확히 알 수 있습니다. 테스트를 먼저 작성해야 다 만들고 나서 이상한 부분을 나중에 찾는 경우를 줄일 수 있습니다. 테스트를 먼저 고민하면 작업 전에 더 많은 결정을 내릴 수 있습니다.

다른 사람의 작업물을 망가뜨리지 않았다는 안정감을 위해서라도 자동화된 단위 테스트 코드 및 자동화된 통합 테스트 코드는 반드시 필요합니다. CI가 빌드만 수행한다면 이런 확신을 얻기 어렵습니다(최근엔 빌드에 테스팅이 기본으로 포함되는 추세죠). CI의 테스팅 과정을 통과하기 위해서 테스트 코드를 빼먹거나 틀리게 작성하는 건 코드 리뷰 때 반드시 잡아내야 합니다.

## 실무에서 TDD를 적용하기 위한 전제가 있을까요?

어떤 일을 하는지 명확해야 합니다. 각 작업이 작으면 더 좋습니다.

TDD는 필연적으로 더 많은 결정, 더 많은 대화, 더 많은 갈등을 만듭니다. 팀이 서로 불신한다면, TDD는 좋은 선택이 아닙니다. 엔지니어링 스킬보다 정치에 더 집중하는 게 낫습니다.

올바른 결과가 무엇인지 알기 어렵다면, TDD를 하기 어렵습니다. 올바른 결과가 무엇인지 팀원들끼리 생각하는 게 다르다면, TDD를 하기 어렵습니다. 우리는 무얼 만들고 있고, 어떻게 이뤄낼 것인가, 이번에는 무엇을 할 것인가, 오늘은 무엇을 하고 이 결정이 내일 어떤 상황을 만들 것인가 같은 걸 함께 이야기하는 게 필요합니다.

## 그래도 어려워요. 여기엔 왜 내가 궁금한 게 빠졌죠?

저에게 연락하세요. 제 이메일은 ahastudio 앳 지메일닷컴 입니다.

다른 의견이나 피드백도 환영합니다.

---

- [2016년 이상한모임 Advent Calendar](https://j.mp/3vfFcIf)
- 이전 글: 12월 2일, [초심자가 타입 시스템에 대해 오해하는 몇 가지](https://j.mp/2gMvjfv)
- 다음 글: 12월 4일, [서버리스 일 년간 약 판 회고](https://j.mp/2gvh2TJ)
