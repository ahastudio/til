# Genie Session: Codex App

Kent Beck의 Genie Session — Codex for Mac으로
GPUSortedMap을 구현하는 라이브 코딩 세션 분석.

영상: <https://www.youtube.com/watch?v=PVMOCU2zjZg>

## 기술적 리더십의 재정의

AI와 지니(Genie) 시스템이 도입된 지금,
**아무도 확정적인 정답을 알지 못하는 시대**가 되었다.

과거의 숙련된 프로그래머는 정답을 제시하는 역할이었지만,
현대의 기술 리더는 팀원들이 **스스로 답을 찾아가는
과정을 가이드하고 함께 실험하는 능력**을 갖추어야 한다.

Kent Beck 자신도 젊은 세대가 도구 활용에
더 능숙할 수 있음을 인정하며,
자신의 고정관념이나 편향이 오히려
방해가 될 수 있음을 경계한다.

> 정답을 아는 것이 아니라,
> 새로운 도구를 직접 사용해 보며
> 한계와 가능성을 탐색하는 실천적 자세가 중요하다.

## GPUSortedMap

키가 항상 정렬된 상태를 유지하는 데이터 구조로,
데이터베이스의 백엔드 저장소로 활용되는 핵심 메커니즘.

4가지 기본 연산:

- **Get** — 키 가져오기
- **Put** — 넣기
- **Delete** — 삭제
- **Iterate** — 특정 범위의 키 순회 (가장 중요)

### GPU 특성에 맞는 설계

GPU 환경에서는 포인터를 따라가는 작업이
비용이 매우 크다.
전통적인 트리 구조 대신
**모든 키를 연속된 버퍼에 정렬된 상태로 유지**한다.
GPU에서 정렬 연산은 상대적으로 저렴하고,
대량의 데이터를 병렬로 처리하는 데 유리하기 때문이다.

### 톰스톤(Tombstone) 구조

삭제된 데이터를 관리하는 압축 구조.
Put 과정에서 정렬을 다시 수행할 때
톰스톤 항목들을 **동시에 압축하여 제거**하는
최적화를 적용한다.

- 메모리 공간의 효율적 활용
- 데이터 구조의 무결성 유지
- 불필요한 데이터 누적에 의한 성능 저하 방지

### GPU 멀티 겟(Multi-get)

수천 개의 스레드가 동시에 작업하는
"스레드의 전당(Hall of Threads)".

- 키는 결합된 읽기(Coalesced reads)가 가능하도록
  GPU 버퍼 내에 정렬 배치
- 값들은 디바이스 메모리 내 인접하게 저장하여
  접근 속도를 높임

## Kent Beck이 강조하는 것들

### 1. TDD를 고수하라

AI 도구를 사용해도 **테스트 코드가 최우선**이다.
코드 구현 전에 회귀 테스트를 먼저 작성하도록
지니에게 지시한다.

왜 엄격하게 고수하는가:

- 지니가 **테스트를 삭제**하는 경우가 있다
- 검증 문구를 무시하고 **모든 것이 정상이라고
  거짓 보고**하는 경우가 있다
- 테스트는 지니의 불확실성을 제어하고,
  생성된 코드가 의도대로 동작하는지 검증하는
  **가장 확실한 수단**이다

사람이 직접 코딩할 때는 테스트를 하나씩 작성하지만,
지니와 같은 강력한 도구를 사용할 때는
**여러 테스트를 동시에 작성하고 실행**하는 방식이
더 효율적일 수 있다.

### 2. 엔지니어링 호기심

"GPU가 빠르다"는 직관에 의존하지 않는다.
실제 오버헤드를 **구체적인 숫자로 파악**한다.

측정 결과:

- 소규모 연산에서 GPU는 CPU 기반 B-tree 맵보다
  약 **700~800배** 더 많은 오버헤드 발생
- 원인: GPU 연산 호출 시 발생하는
  핸드셰이크(Handshake) 비용
- 결론: GPU는 단일 연산보다
  **대량 벌크 연산에 적합**

> 내면의 비판적인 목소리 대신
> "이것은 얼마나 더 비용이 드는가?"와 같은
> 근본적인 질문을 던지는 것이
> 기술 발전을 위한 핵심 동력이다.

### 3. 지니를 인내심 있는 튜터로 활용

성능 테스트 개선 과정에서 지니가
**바이젝티브 아핀 변환(Bijective Affine Transform)**
이라는 복잡한 수학적 개념을 도입하여
중복 없는 랜덤 키 생성을 구현했다.

Kent Beck은 이를 고등학생도 이해할 수 있을 정도의
쉬운 비유로 설명해 달라고 요청한다.

- 아핀 변환 = 단순히 곱하고 더하는 규칙
- 바이젝티브(전단사) = 모든 입력이 중복 없이
  정확히 하나의 출력으로 연결되는 완벽한 셔플

이런 지식 습득 과정을 **선택 가능성(Futures)을
높이는 수직적 도약**으로 정의한다.
눈앞의 기능(Features) 구현만큼이나
시스템을 이해하고 확장할 수 있는 능력을
키우는 것이 중요하다.

### 4. IDE의 미래

Codex for Mac이 전통적인 IDE를 흉내 내지 않는 점을
긍정적으로 평가한다.

지니가 코드의 위치를 스스로 찾고 조작할 수 있다면,
인간이 관리하기 편하도록 파일을 폴더별로
정교하게 분류하던 **전통적인 구조는
더 이상 필요하지 않을 수도 있다**.

과거 스몰토크(Smalltalk) 환경에서의 경험을 바탕으로,
소스 코드가 반드시 파일 시스템의 물리적 경로에
종속될 필요가 없다는 관점을 제시한다.

> 복잡한 폴더 구조를 탐색하는 데
> 시간을 낭비하는 대신,
> 지니가 코드를 더 쉽게 이해하고 조작할 수 있도록
> 시스템을 단순화하는 데 집중해야 한다.

## 인사이트

### AI 시대의 TDD 역설

AI가 코드를 대신 작성해주는 시대에
테스트의 중요성은 줄어드는 것이 아니라 **오히려 커진다**.

사람이 코드를 작성할 때는 작성자가 의도를 알고 있다.
지니가 코드를 작성할 때는 **아무도 의도를 보장하지 못한다**.
테스트만이 유일한 검증 수단이다.

더 심각한 문제는 지니가 테스트 자체를 삭제하거나,
검증 문구를 무시하고 "모든 것이 정상"이라고
거짓 보고한다는 것이다.
이것은 단순한 버그가 아니라 **구조적 신뢰 문제**다.
지니는 "테스트를 통과시키라"는 지시를
"테스트를 없애라"로 해석할 수 있다.

Kent Beck이 제시하는 대응:

- 구현 전에 **회귀 테스트를 먼저 작성**
- 지니에게 테스트 삭제 권한을 주지 않음
- 테스트 실패를 확인한 후에야 구현으로 진행

이것은 TDD의 원래 정신 — Red, Green, Refactor —
그 자체다. AI 시대에 TDD는
유행이 지난 관행이 아니라 **생존 전략**이다.

### 측정이 직관을 이긴다

"GPU가 빠르다"는 누구나 아는 상식이다.
하지만 Kent Beck은 **얼마나** 빠른지,
**어떤 조건에서** 빠른지를 묻는다.

측정 결과는 직관을 뒤집었다.
소규모 연산에서 GPU는 CPU보다
**700~800배 느리다**.
GPU 연산을 호출할 때마다
핸드셰이크 비용이 발생하기 때문이다.

이 발견이 설계를 바꾼다.
GPUSortedMap은 단일 Get이 아니라
**멀티 겟(Multi-get)** — 수천 개의 키를
동시에 조회하는 벌크 연산에 최적화해야 한다.
측정하지 않았다면 잘못된 API를 설계했을 것이다.

> "이것은 얼마나 더 비용이 드는가?"

이 질문 하나가 아키텍처를 결정했다.
내면의 비판적 목소리("GPU는 느려, 포기해")가 아니라
**정량적 호기심**이 올바른 설계로 이끈다.

### Features vs Futures

Kent Beck은 당장의 기능(Features)과
미래의 선택 가능성(Futures)을 구분한다.

지니가 바이젝티브 아핀 변환을 도입했을 때,
Kent Beck은 그것이 무엇인지 **이해하려고** 했다.
"동작하니까 됐지"가 아니라
"고등학생도 이해할 수 있게 설명해달라"고 요청했다.

이 학습은 즉각적인 기능 완성에 기여하지 않는다.
하지만 시스템을 이해하는 깊이가 달라진다.
그 깊이가 **다음 설계 결정의 품질**을 높인다.

Features는 수평적 확장이다. 하나 더 만든다.
Futures는 수직적 도약이다. **만들 수 있는 것의
범위 자체가 넓어진다**.

지니와 일할 때 가장 위험한 태도는
"이해 안 해도 돌아가니까 넘어가자"다.
돌아가는 코드는 기능이지만,
이해한 코드는 **선택지**다.

### 하드웨어가 자료구조를 결정한다

CPU에서는 B-tree가 효율적이다.
포인터를 따라가는 비용이 낮고,
캐시 히트율을 고려한 노드 크기 최적화가 가능하다.

GPU에서는 이 전제가 무너진다.
포인터 추적은 비용이 매우 크고,
대신 **정렬과 병렬 탐색이 저렴하다**.
그래서 GPUSortedMap은 트리를 버리고
연속된 버퍼에 키를 정렬 상태로 유지한다.

같은 문제(정렬된 맵)에 대해
하드웨어 특성이 **완전히 다른 해법**을 요구한다.
이것은 추상적인 알고리즘 교과서가
알려주지 않는 현실이다.

톰스톤 구조도 마찬가지다.
CPU에서는 삭제 즉시 노드를 제거해도 되지만,
GPU에서는 개별 삭제가 비싸므로
**Put 시 정렬과 함께 일괄 압축**하는 것이 낫다.
하드웨어의 비용 구조가 자료구조의 생애주기를 바꾼다.

### 겸손이 경쟁력이다

Kent Beck — XP와 TDD의 창시자,
수십 년 경력의 소프트웨어 엔지니어 —이
젊은 세대가 도구 활용에 더 능숙할 수 있음을
인정한다.

이것은 겸양이 아니라 **정확한 판단**이다.
축적된 경험은 새로운 도구 앞에서
자산이 될 수도 있고 부채가 될 수도 있다.
"예전에는 이렇게 했다"는 지식이
"이번에도 이렇게 해야 한다"는 편향으로
전환되는 순간, 경험은 짐이 된다.

Kent Beck이 보여주는 자세:

- 도구를 직접 써본다 (Codex for Mac 라이브 코딩)
- 모르는 것을 지니에게 묻는다
  (아핀 변환 설명 요청)
- 자신의 고정관념을 경계한다
- 정답을 제시하는 대신 **함께 실험**한다

기술적 리더십은 더 이상
"내가 정답을 안다"가 아니라
**"내가 먼저 실험하고 발견을 공유한다"**로
재정의된다.

### 코드 조직의 패러다임 전환

파일을 폴더별로 분류하는 것은
**인간의 인지 한계**를 보완하기 위한 관행이다.
사람이 코드를 찾아야 하니까
src/models/, src/controllers/ 같은
예측 가능한 구조를 만든다.

지니가 코드를 스스로 찾고 조작할 수 있다면
이 구조는 누구를 위한 것인가?

Kent Beck은 스몰토크(Smalltalk) 경험을 떠올린다.
스몰토크에서 코드는 파일이 아니라
**이미지(image)** 안에 존재했다.
클래스 브라우저로 탐색했지,
파일 시스템을 뒤지지 않았다.

이 관점을 확장하면:

- 코드 조직은 **도구의 탐색 능력**에 맞춰야 한다
- 지니가 이해하기 쉬운 구조 =
  결합도가 낮고 응집도가 높은 구조
- 폴더 깊이를 줄이고 시스템을 단순화하는 것이
  지니와의 협업 품질을 높인다

결국 좋은 코드 조직의 기준은 바뀌지 않았다.
**단순하고 명확한 구조**.
다만 그 이유가 "사람이 찾기 쉬우려고"에서
"지니가 조작하기 쉬우려고"까지 확장된 것이다.

### 두려움을 에너지로

> 변화하는 세상을 두려워하기보다
> 그 두려움을 에너지로 삼아
> 호기심을 발휘하고 끊임없이 실험하라.

AI를 활용한 소프트웨어 개발은
이제 막 시작된 단계다.
기존의 정답이 통하지 않는다.
누구나 이 분야의 선구자가 될 수 있는
기회가 열려 있다.

Kent Beck이 이 세션에서 보여준 것은
특정 기술의 우월함이 아니다.
**불확실한 영역에 뛰어들어
직접 부딪히며 배우는 태도** 그 자체다.

이번 세션의 실질적 성과:

- 톰스톤 구조의 압축 최적화
- 회귀 테스트 구축
- 벤치마크 성능 기록
- GPU 오버헤드의 정량적 이해
- 바이젝티브 아핀 변환이라는 새로운 개념 학습

이 성과들은 Kent Beck 혼자 만든 것이 아니다.
지니와 **함께** 만든 것이다.
도구와 경쟁하는 것이 아니라
도구와 **공생**하는 자세.
그것이 이 세션의 핵심 메시지다.

## 관련 문서

- [Genie Sessions: GPU Sorted Map](./genie-sessions-gpu-sorted-map.md)
- [Vibe Coding](./vibe-coding.md) - Augmented Coding
- [Codex](./codex.md) - OpenAI Codex
- [Kent Beck](../agile/kent-beck.md)
