# 골빈해커의 코딩 에이전트 프롬프팅 플로우 분석

골빈해커(@golbin)의 트윗 (2026년 2월):
<https://twitter.com/golbin/status/2022204980548243627>

## 원문

> 나의 코딩 에이전트 프롬프팅 플로우
>
> 1. 계획을 세우라 한다
> 2. 계획을 검토하라 한다
> 3. 검토한게 맞는지 검토하라 한다
> 4. 계획이 과도하지 않은지 검토하라한다
> 5. 구현을 시킨다
> 6. 구현이 목적에 맞게 잘 됐는지 검토하라 한다
> 7. 잠재적인 버그나 크리티컬 이슈,
>    보안 문제등을 검토하라 한다
> 8. 개선한 내용들에 문제는 없는지 검토하라 한다
> 9. 매우 큰 함수와 파일이 있다면
>    적절한 크기로 나누도록 한다
> 10. 기존의 코드와 통합하거나 재사용 할 수 있는
>     부분이 있는지 검토하라고 한다
> 11. 사이드 이펙트는 없는지 확인하라고 한다
> 12. 전체 변경 사항을
>     다시 한 번 검토하라고 한다
> 13. 구현 과정에서 불필요해진 코드가 있다면
>     정리하라고 한다
> 14. 코드 품질이 충분히 높은지 검토하라고 한다
> 15. 사용자의 사용 흐름에서
>     문제는 없는지 확인하라고 한다
> 16. (그 외 검토중에 발견된 문제에 대한
>     예상된 관련 부분들 백번 검토시킴)
> 17. 이대로 배포해도 될 정도의 퀄리티인지
>     다시 한 번 검토하라고한다.
> 18. 커밋하고 PR 작성

## 플로우 구조 분석

18단계를 크게 네 페이즈(Phase)로 나눌 수 있다.

### Phase 1: 계획 수립 및 검증 (1~4단계)

계획을 세우고, 세 번의 검토를 거친다.

1. **계획 수립** - 무엇을 할 것인가
2. **계획 검토** - 계획이 올바른가
3. **검토의 검토** - 검토가 정확한가 (메타 검증)
4. **과도함 검토** - 오버엔지니어링은 없는가

계획 단계에서 검토를 세 번 하는 것이 핵심이다.
특히 4단계의 과도함 검토는 AI 에이전트의 고질적인 문제인
과잉 복잡화(Over-engineering)를 사전에 차단한다.
Karpathy도 지적한 "코드 과잉 복잡화, 추상화 부풀리기"와
정확히 같은 문제를 인식하고 있다.

### Phase 2: 구현 (5단계)

전체 18단계 중 구현은 **단 한 단계**다.
계획 4단계, 검토 12단계에 비해 구현이 1단계라는
비율이 이 플로우의 철학을 드러낸다.
에이전트에게 구현은 쉽고, 올바른 구현이 어렵다.

### Phase 3: 다층 검토 (6~16단계)

구현 후 11단계에 걸쳐 서로 다른 관점으로 검토한다.

| 단계 | 검토 관점               | 검토 유형      |
| ---- | ----------------------- | -------------- |
| 6    | 목적 부합               | 기능 검증      |
| 7    | 버그, 보안, 크리티컬    | 안전성 검증    |
| 8    | 개선 사항의 부작용      | 변경 검증      |
| 9    | 함수/파일 크기          | 구조 개선      |
| 10   | 코드 통합/재사용        | 중복 제거      |
| 11   | 사이드 이펙트           | 영향 범위 검증 |
| 12   | 전체 변경 사항          | 통합 검토      |
| 13   | 불필요한 코드 정리      | 데드코드 제거  |
| 14   | 코드 품질               | 품질 게이트    |
| 15   | 사용자 흐름(UX)         | 사용성 검증    |
| 16   | 발견된 문제의 연쇄 검토 | 반복 검증      |

각 검토가 서로 다른 차원을 다루고 있다.
기능 → 안전성 → 구조 → 중복 → 영향 → 전체 → 정리
→ 품질 → UX → 연쇄 검토 순서로
점점 범위를 넓혀가며 검토한다.

### Phase 4: 최종 게이트 및 배포 (17~18단계)

17단계에서 "배포 가능 수준인가"라는 최종 품질 게이트를
통과시킨 후, 18단계에서 커밋과 PR을 작성한다.

## 인사이트

### 1. 검토 주도 개발(Review-Driven Development)

18단계 중 구현은 1단계, 나머지 17단계는 계획과 검토다.
이는 AI 에이전트의 본질적 특성을 정확히 파악한 설계다.
에이전트는 코드를 생성하는 능력은 뛰어나지만,
생성한 코드의 적절성을 스스로 판단하는 능력은 부족하다.
사람이 검토 방향을 잡아줘야 한다.

### 2. 다관점 검토의 가치

하나의 "검토해줘"가 아니라 11개의 개별 관점을 제시한다.
"버그 없어?", "코드 품질 괜찮아?", "UX 문제없어?" 등
각각 다른 렌즈를 씌워줘야 AI가 해당 관점에 집중한다.
AI에게 "전반적으로 검토해줘"라고 하면
실제로는 아무것도 깊이 보지 않는 경향이 있다.

### 3. 메타 검증 패턴 (검토의 검토)

3단계의 "검토한게 맞는지 검토"는 메타 검증이다.
AI가 스스로의 판단을 다시 판단하게 하는
자기 반성(Self-reflection) 프롬프팅 기법과 일맥상통한다.
이는 AI의 확증 편향(Confirmation bias)을 완화하는
효과적인 방법이다.

### 4. 오버엔지니어링 방어

4단계에서 계획이 과도하지 않은지 명시적으로 검토한다.
AI 에이전트는 주어진 지시를 충실히 따르려다
불필요한 추상화, 미래 대비 코드, 과잉 설계를 만들어낸다.
이를 구현 전에 차단하는 것은 비용 효율적이다.
구현 후에 "줄여봐"라고 하는 것보다
계획 단계에서 "과도하지 않은지 봐"라고 하는 것이 낫다.

### 5. 연쇄 검토 (16단계)

"백번 검토시킴"이라는 표현은 과장이지만 핵심을 찌른다.
한 문제를 고치면 다른 문제가 생길 수 있고,
그 문제를 고치면 또 다른 문제가 생길 수 있다.
이 반복 루프를 명시적으로 인정하고 수행하는 것이
플로우의 실전 경험에서 나온 부분이다.

## 교훈

### AI는 주니어 개발자처럼 다뤄야 한다

이 플로우는 본질적으로 **시니어 개발자가 주니어의
코드 리뷰를 하는 프로세스**와 동일하다.
계획서를 쓰게 하고, 계획서를 리뷰하고,
구현하게 하고, 여러 관점에서 리뷰한다.
다만 주니어와 다른 점은,
AI는 리뷰 관점을 명시적으로 지정해줘야 한다는 것이다.

### 한 번에 모든 것을 기대하지 않는다

하나의 거대한 프롬프트로 모든 것을 해결하려 하지 않고,
단계별로 나누어 각각의 목표를 명확히 한다.
이는 프롬프트 엔지니어링의 기본 원칙인
"작업 분해(Task Decomposition)"와 일치한다.

### 배포 전 최종 게이트의 중요성

17단계에서 "배포 가능한 수준인가?"라는 질문은
모든 검토를 종합하는 최종 판단이다.
개별 검토를 다 통과해도
전체적으로 배포 수준이 아닐 수 있다.
숲을 보는 마지막 점검이 필요하다.

## 개선 가능한 점

### 1. 테스트 단계 부재

플로우에 테스트 작성 및 실행 단계가 없다.
6~16단계의 검토는 모두 에이전트의 "눈으로 보는 검토"다.
실제 테스트 코드를 작성하고 실행하는 단계를 추가하면
검토의 신뢰도가 올라간다.

제안: 5단계(구현) 직후에 "테스트를 작성하고 실행하라"
단계를 삽입한다.

### 2. 반복 루프의 구조화

16단계의 "백번 검토"는 종료 조건이 불명확하다.
"더 이상 문제가 발견되지 않을 때까지"라는
명시적인 종료 조건을 추가하면
에이전트가 무한 루프에 빠지거나
너무 일찍 종료하는 것을 방지할 수 있다.

### 3. 성능 관점 검토 추가

기능, 보안, 코드 품질, UX는 검토하지만
성능(Performance) 관점의 검토가 빠져 있다.
N+1 쿼리, 불필요한 렌더링, 메모리 누수 등
성능 이슈는 별도의 관점으로 검토할 가치가 있다.

### 4. 문서화 및 커밋 메시지 품질

18단계에서 "커밋하고 PR 작성"이라고만 되어 있다.
커밋 메시지의 품질, PR 설명의 충실함,
변경 사항에 대한 문서화도 명시적으로 요구하면
코드 리뷰어(사람)의 부담을 줄일 수 있다.

### 5. CLAUDE.md 등 규칙 파일 활용

매번 18단계를 수동으로 프롬프팅하는 것은 비효율적이다.
`CLAUDE.md`나 `.cursorrules` 같은 규칙 파일에
이 플로우를 내장하면 자동으로 적용된다.
다만, Karpathy가 지적했듯이
규칙 파일로 지시해도 완벽히 따르지는 않는다.

## 관련 문서

- [Karpathy's Claude Coding Notes](./karpathy-claude-coding-notes.md)
- [File-based Planning Workflow](./file-based-planning-workflow.md)
- [Spec-Driven Development](./spec-driven-development.md)
- [Vibe Coding](./vibe-coding.md)
