# AI Agent Workflow Orchestration Guidelines

[AI Agent Workflow Orchestration Guidelines](
https://gist.github.com/OmerFarukOruc/a02a5883e27b5b52ce740cadae0e4d60
)

AI 코딩 에이전트를 실제 코드베이스에서 올바르게 운영하기 위한
종합 가이드라인이다.

## 핵심 철학

| 원칙                    | 해석                                  |
| ----------------------- | ------------------------------------- |
| Correctness > Cleverness | 영리한 코드보다 읽히는 코드           |
| Smallest blast radius   | 수정 범위를 최소한으로 제한           |
| Leverage existing       | 새 추상화 전에 기존 패턴 우선         |
| Prove it works          | "아마 될 것 같다"는 완료가 아님       |

## 워크플로우 전략

### 1. Plan Mode Default

3단계 이상, 다중 파일 변경, 아키텍처 결정, 프로덕션 영향이 있는
작업은 반드시 계획부터 시작한다.
새 정보가 계획을 무효화하면 즉시 중단하고 계획을 수정한다.

### 2. Subagent Strategy

서브에이전트를 활용해 컨텍스트를 분리하고 병렬 작업을 수행한다.

- 레포 탐색, 패턴 발견, 테스트 실패 분석, 의존성 조사
- 각 서브에이전트에 단일 목표와 구체적 산출물을 부여
- 코딩 시작 전에 결과를 종합

서브에이전트의 핵심 가치는 속도가 아니라 **컨텍스트 오염 방지**다.

### 3. Incremental Delivery

빅뱅 방식 대신 얇은 수직 슬라이스(thin vertical slice)로 전달한다.
각 슬라이스는 DB부터 UI까지 완전히 동작하는 최소 단위여야 한다.
기능 플래그(feature flag)나 안전한 기본값을 적극 활용한다.

### 4. Self-Improvement Loop

```
실수 발생
  → tasks/lessons.md에 기록 (실패 모드, 감지 신호, 예방 규칙)
  → 세션 시작 / 대형 리팩터 전에 재열람
```

세션 간 기억을 파일로 외재화(externalize)하여 같은 실수를 반복하지
않는다. 인간 팀의 포스트모템(postmortem) 문화를 에이전트에 이식한
메커니즘이다.

### 5. Verification Before "Done"

증거(테스트, 빌드, 린트, 로그) 없이는 완료로 표시하지 않는다.
변경 전후 동작을 비교하는 검증 스토리(verification story)가 필요하다.

### 6. Demand Elegance

비자명한 변경에 대해 "부품을 줄일 수 있는가?"를 스스로 묻는다.
단순한 버그 수정에는 과설계(over-engineering)를 피한다.

### 7. Autonomous Bug Fixing

재현 → 원인 격리 → 수정 → 회귀 커버리지 → 검증 순서로 진행한다.
막힌 경우에만 사용자에게 질문하되, 한 번에 하나의 질문과 권장
기본값을 함께 제시한다.

## 태스크 관리 (파일 기반, 감사 가능)

`tasks/todo.md`에 체크리스트를 생성하고 명시적 완료 기준을 정의한다.
한 번에 하나의 항목만 진행 중 상태로 유지한다.
`tasks/lessons.md`에 수정 사항이나 포스트모템 후 교훈을 기록한다.

## 커뮤니케이션 원칙

- **결과 우선**: 파일 경로, 명령어, 에러 메시지 등 구체적 아티팩트를
  제시한다.
- **질문 경제**: 막힌 경우에만, 딱 한 가지 질문을 한다.
- **Busywork 금지**: 모든 단계를 중계하지 않는다. 체크포인트 공유
  조건은 4가지뿐이다: 스코프 변경, 리스크 발견, 검증 실패, 결정 필요.

## 에러 처리 및 복구

### Stop-the-Line Rule

예상치 못한 실패(테스트 실패, 빌드 오류, 동작 회귀)가 발생하면
**기능 개발을 즉시 중단**하고 에러 출력과 재현 단계를 보존한다.
제조업의 안돈 코드(Andon cord) 개념을 에이전트에 적용한 원칙이다.

### Triage 순서

1. 신뢰성 있게 재현
2. 실패 레이어 특정 (UI / API / DB / 네트워크 / 빌드)
3. 최소 실패 케이스로 축소
4. 증상이 아닌 근본 원인 수정
5. 회귀 커버리지 추가
6. 원래 리포트에 대한 End-to-End 검증

### 안전한 폴백

- "안전 기본값 + 경고" 방식을 선호한다.
- 수정 수단으로 광범위한 리팩터를 피한다.
- 프로덕션 영향이 불확실하면 기본값 비활성화 플래그로 배포한다.

## Definition of Done

- 동작이 완료 기준(acceptance criteria)과 일치한다.
- 테스트/린트/타입체크/빌드가 통과했거나 미실행 이유가 문서화됐다.
- 위험한 변경은 롤백 또는 플래그 전략이 있다.
- 코드가 컨벤션을 따르고 읽기 쉽다.
- 검증 스토리가 존재한다: 무엇이 바뀌었고 어떻게 정확성을 확인했는지.

## 인사이트: 이 문서가 의미하는 것

### 에이전트를 주니어 개발자로 취급하지 않는다

기존 AI 활용 가이드는 "이렇게 해라"는 지시 목록이 많다.
이 문서는 다르다. 원칙과 판단 기준을 제공하고 상황에 따른
자율 판단을 유도한다. 에이전트를 실행자가 아닌 **의사결정자**로
설계한다는 철학이 전제되어 있다.

실제로 Plan Mode, Subagent Strategy, Stop-the-Line Rule 모두
"언제 무엇을 해야 하는가"의 트리거를 스스로 인식하도록 설계되어
있다. 규칙이 아니라 판단력을 심는 것이다.

### 파일 시스템이 에이전트의 외재화된 기억이다

```
컨텍스트 윈도우 (휘발성)
  → tasks/todo.md     ← 계획 및 진행 상태
  → tasks/lessons.md  ← 실수와 예방 규칙
```

에이전트는 세션이 끊기면 기억을 잃는다. 이 문서는 그 한계를
회피하지 않고 정면으로 설계에 반영한다. 파일에 기억을 쓰고,
세션 시작 때 읽고, 실수를 기록하고, 반복을 막는다.

단순한 메모가 아니다. 에이전트가 **시간을 가로질러 일관성을
유지**하는 유일한 메커니즘이다. 컨텍스트 윈도우 제한을 극복하면서
감사 가능성(auditability)과 재현 가능성(reproducibility)을 동시에
확보한다.

### 롤백 우선 설계가 기본값이다

AI 에이전트는 실수한다. 이 문서는 그 사실을 공리(axiom)로
받아들인다. 그래서 모든 변경은 되돌릴 수 있도록 설계하는 것이
기본값이다.

- 기능 플래그(feature flag)로 변경을 격리
- 설정 게이팅으로 프로덕션 영향을 지연
- 원자적(atomic) 커밋으로 롤백 단위를 명확히

"잘못되면 되돌리면 된다"가 아니라, **"처음부터 되돌릴 수 있게
만든다"**는 설계 원칙이다. 에이전트의 자율성을 신뢰하되,
그 신뢰에는 항상 안전망이 따른다.

### 검증 스토리가 완료의 조건이다

"동작한다"는 말은 증거가 아니다. 이 문서에서 완료(Done)는
**검증 스토리(verification story)**가 존재할 때만 성립한다.
무엇이 바뀌었고, 어떻게 확인했고, 실패했다면 왜 실패했는지를
서술할 수 있어야 한다.

이는 코드 리뷰어가 없는 자율 에이전트 환경에서 품질 보증의
최후 방어선이다. 다음 에이전트 또는 다음 세션이 맥락 없이도
변경 의도를 파악할 수 있도록 설계된 요건이다.

### Stop-the-Line은 용기의 문제다

제조업의 안돈 코드(Andon cord)는 작업자 누구나 라인을 멈출 수
있는 권한을 준다. AI 에이전트에서 이 원칙은 더 중요하다.
에이전트는 실패를 우회하거나 무시하며 진행할 유혹이 크기 때문이다.

예상치 못한 실패가 발생하면 **즉시 멈추고, 보존하고, 재진단**한다.
멈추는 것이 용기 있는 행동이다. 계속 달리는 것이 위험이다.

### "Busywork" 금지는 신호 대 잡음비의 문제다

에이전트가 모든 행동을 중계하면 사용자는 정보 과부하에 빠진다.
이 문서는 커뮤니케이션을 **4가지 트리거**로 엄격히 제한한다:
스코프 변경, 리스크 발견, 검증 실패, 결정 필요.

결과적으로 에이전트의 메시지는 신호(signal)만 남고 잡음(noise)이
제거된다. 사용자 신뢰는 빈도가 아니라 정확성에서 온다.

> **핵심 요약**: AI 에이전트를 똑똑하게 만드는 것보다, 실수했을 때
> 빠르게 멈추고, 기록하고, 복구하는 시스템이 더 중요하다.

## 관련 문서

- [File-based Planning Workflow](./file-based-planning-workflow.md)
- [Spec-Driven Development](./spec-driven-development.md)
