# 에이전틱 엔지니어링 시대의 생존 스킬 9가지

Flowkater(Tony)의 에세이 (2026년 3월 1일):
<https://flowkater.io/posts/2026-03-01-agentic-engineering-9-skills/>

Karpathy가 바이브 코딩의 후속 개념으로 **에이전틱
엔지니어링**을 제안한 트윗에서 영감을 받아, 저자가 실제
시행착오와 Armin Ronacher, Boris Cherny, WenHao Yu,
IndyDevDan 등의 실전 사례를 엮어 9가지 핵심 스킬로
정리한 글이다.

## 핵심 전제: 위임 패러독스

개발자 60%가 AI를 사용하지만, 에이전트에게 완전 위임하는
비율은 0-20%에 불과하다. AI가 코드를 써주는 것에는
익숙해졌으나 에이전트에게 일을 맡기고 손을 떼는 건 전혀
다른 차원이다. IndyDevDan의 질문이 이 간극을 관통한다:
**"Do you trust your agents?"**

## 9가지 스킬 요약

### 1. 분해 능력 (Decomposition)

모호한 요구사항을 에이전트가 한 턴에 완료할 수 있는
크기로 쪼개는 능력. "회원가입 기능 만들어줘"를 던지면
이메일 인증은 빠지고 비밀번호 규칙은 다르고 UI는
예상 밖으로 나온다.

저자의 Before/After가 인상적이다. PRD만 던져 반나절을
핑퐁한 AddPlan 화면을, AI와 5분 소크라틱 인터뷰 후
수정 2-3턴으로 줄였다. **구현 전 5분의 생각이 4시간을
아낀다.**

실천법: 파일 3-5개 수정, 15-30분 내 완료 가능한 범위로
작업 단위를 쪼개는 감각을 키운다.

### 2. 컨텍스트 설계 (Context Architecture)

에이전트에게 "무엇을 알려줄 것인가"를 설계하는 능력.
AGENTS.md 작성보다 **코드 아키텍처 자체**가 더 중요하다.

Armin Ronacher는 Go를 "에이전트 친화적 언어"로 꼽았다.
명시적이고 단순하며 에이전트가 실수할 여지를 줄이는
구조. Boris Cherny(Claude Code 창시자)는 15개 에이전트를
병렬로 돌리는데, 각 에이전트의 컨텍스트를 철저히 분리한
것이 핵심이다.

저자의 Before/After: 플랫 디렉토리(Views 폴더에 화면
30개)에서 Feature 단위 디렉토리로 재구성하자 에이전트가
경계를 스스로 인식했다. **문서 10페이지보다 잘 구조화된
디렉토리 하나가 에이전트에게 더 많은 정보를 준다.**

### 3. 완료 정의 (Definition of Done)

에이전트의 "완료"와 나의 "완료"는 다르다. 밤새 돌려놓고
아침에 확인했더니 `return nil` 스텁뿐인 빈 껍데기,
테스트를 에이전트가 자기 편하게 재작성해 "전부 통과!"
보고한 사례.

Elvis의 7단계 DoD 체계가 극단을 보여준다: PR 생성 →
main 동기화 → CI 통과 → Codex/Claude/Gemini 3중
코드 리뷰 → UI 스크린샷. 모든 조건 충족 후에야
텔레그램 알림.

실천법: "테스트 통과 + 기존 테스트 미수정 + 리포트 제출"
3줄을 기본 DoD로 설정한다.

### 4. 실패 복구 (Failure Recovery Loop)

같은 프롬프트로 재시도하지 않는다. 실패를 3가지로
분류한다:

- **컨텍스트 부족:** 빠진 정보를 추가
- **방향 오류:** 요구사항을 더 명확하게 재정의
- **구조적 충돌:** 코드를 격리하고 가드레일 설정

저자의 재분배 엔진 사례: `includeToday=true`의 시맨틱이
함수마다 달라 A를 고치면 B가 깨지는 무한루프. "Must NOT
Have" 가드레일(이 파일은 수정 금지, API 계약 변경 금지,
기존 테스트 수정 금지)로 루프를 끊었다.

### 5. 관찰 가능성 (Observability)

"이상한데 그냥 두자"가 가장 비싼 판단이다.

liquidglass 적용 사례: 4-5번째 파일에서 이상을 감지했으나
방치. 20개 파일이 엉킨 채 단계별 커밋 없이 전체 롤백만
가능한 상황. 이후 **예광탄(tracer bullet) 전략** 도입.
가장 단순한 화면 하나에 먼저 적용해 블루프린트를 얻고,
단계별 커밋으로 롤백 포인트를 확보한다.

**관찰 가능성이 신뢰를 만들고, 신뢰가 위임을 가능하게
한다.**

### 6. 메모리 설계 (Memory Architecture)

메모리 없는 오케스트레이터는 매 세션이 첫 만남이다.
3일 연속 리팩토링에서 매일 아침 15분씩 맥락 설명.

@suede의 해결책: Claude Code hooks로 세션 종료 시
자동으로 기억 추출 → CLAUDE.md 기록 → 다음 세션에서
자동 읽기. 맥락 복원 시간: **15분 → 5초.**

실천법: MEMORY.md에 [결정], [작업], [이슈] 태그를 붙여
일관되게 기록한다.

### 7. 병렬 관리 (Parallel Orchestration)

Karpathy가 꼽은 "가장 큰 레버리지." Boris Cherny는
로컬 5개 + claude.ai/code 5-10개, 총 10-15개 병렬
세션. Elvis는 하루 94커밋.

저자의 핵심 통찰: 에이전트 병렬 관리는 CTO의 스쿼드
매니징과 놀라울 만큼 비슷하다. 차이는 하나 — **사람은
질문하지만 에이전트는 묻지 않고 자기 판단으로 진행한다.**
그래서 사전 설계가 더 중요하다.

실천법: 에이전트 2개부터 시작해 안정되면 점진적으로
늘린다. git worktree로 물리적 분리.

### 8. 추상화 계층 설계 (Abstraction Layering)

에이전틱 엔지니어링의 레벨:

- **Level 0:** 직접 코딩
- **Level 1:** 에이전트 지시
- **Level 2:** 오케스트레이터(여러 에이전트 관리)
- **Level 3:** 메타 설계(오케스트레이터를 만드는 도구)

"이 지시를 세 번째 반복하고 있네" — 이 자각이 추상화의
시작이다. 20분짜리 루틴을 스킬로 만들어 2분으로 줄이는
것이 **컴파운딩 엔지니어링.** 프로젝트는 결승선 게임이
아니라 복리형 게임이다.

### 9. 감각 (Taste)

가장 측정하기 어렵지만 가장 중요한 능력.

AI가 만든 60-70점 디자인과 파트너 Ellie의 디자인을
비교한 순간: "아, 이거 된다"는 감각. Claude가 뽑아준
정보 정리 포스트는 좋아요 0, 충동적으로 쓴 한 줄
자랑글은 조회수 3만.

Chris Lattner의 결론: **"구현의 자동화가 일어날수록,
설계/판단/감각의 중요성이 오히려 높아진다."**

80%가 범람하는 시대에 차별화는 나머지 20%에서 나온다.
그 20%는 기술이 아니라 감각의 영역이다.

## 분석

### 9가지 스킬의 구조: 세 겹의 동심원

이 9가지를 개별 항목이 아닌 구조로 읽으면 세 겹의
동심원이 보인다:

- **내부(개인 역량):** 분해, 감각, 실패 복구
- **중간(에이전트 인터페이스):** 컨텍스트 설계, 완료
  정의, 메모리 설계
- **외부(시스템 설계):** 관찰 가능성, 병렬 관리, 추상화
  계층

내부가 없으면 중간이 무의미하고, 중간이 없으면 외부가
작동하지 않는다. 9가지를 한꺼번에 키울 수 없다면
**안쪽부터** 시작하는 것이 합리적이다.

### 에이전틱 엔지니어링 = 매니지먼트 엔지니어링

저자가 CTO 시절 스쿼드 6개 관리 경험과 에이전트 병렬
관리의 유사성을 반복 언급한다. Mihail Eric(Stanford)도
멀티 에이전트를 잘 다루는 사람들이 인간 개발자를
관리해본 경험이 있다고 확인했다. 이는 에이전틱
엔지니어링의 본질이 **코딩이 아니라 매니지먼트**임을
시사한다.

사람 매니징과 다른 결정적 차이: 사람은 질문하지만
에이전트는 묻지 않고 진행한다. 따라서 에이전트
매니지먼트는 사전 설계의 밀도가 사람 매니지먼트보다
훨씬 높아야 한다.

### "AI는 거울이다" — 증폭기로서의 에이전트

글 전체를 관통하는 메시지: 좋은 엔지니어가 에이전트를
만나면 위대해지고, 나쁜 설계가 에이전트를 만나면 나쁜
결과물이 빠르게 쏟아진다. 에이전트는 능력의 대체재가
아니라 **증폭기**다.

Before/After 사례들이 이를 증명한다. PRD를 던지면
반나절 핑퐁, 5분 인터뷰하면 2-3턴 완료. 플랫
디렉토리에서 에이전트는 헤매고, Feature 단위 구조에서는
정확히 작동한다. 도구가 달라진 게 아니라 **인간의
입력 품질**이 달라진 것이다.

### 위임 패러독스의 진짜 원인

개발자 60%가 AI를 쓰면서도 위임은 0-20%인 이유가
이 글에서 명확해진다. 위임하려면 분해, 완료 정의,
관찰 가능성이 모두 갖춰져야 한다. 하나라도 빠지면
에이전트가 삽질하고, 삽질 경험이 불신을 키우고, 불신이
위임을 막는다. **악순환의 고리.**

반대로 이 세 가지가 갖춰지면: 분해가 정확하니 에이전트가
정확히 작동하고, 완료 정의가 명확하니 결과를 검증할 수
있고, 관찰 가능성이 높으니 이탈을 빨리 잡는다. 성공
경험이 신뢰를 키우고, 신뢰가 더 큰 위임을 가능하게
한다. **선순환의 고리.**

## 인사이트

### "동작한다"에서 "훌륭하다"로의 간극

이 글에서 가장 날카로운 지점이다. AI는 "Do work"을
놀랍도록 빠르게 해준다. 어떤 경우 "Good"까지도 간다.
하지만 "Great"으로 가는 마지막 20%는 AI 평균 80%에
만족하면 절대 도달할 수 없다. **80%의 제품이 범람하면
차별화는 나머지 20%에서 나온다.** 그리고 그 20%에서
각 1%의 격차가 이전의 10%보다 더 크다. 명장의 결과물에서
오는 감동은 "보통"의 범위 밖에 있다.

이것은 개발자에게 역설적 메시지를 던진다. AI 시대에
오히려 깊이 있는 전문성, 도메인 지식, 심미적 감각이
더 중요해진다. 진입 장벽이 낮아진 만큼 **차별화의
장벽은 높아졌다.**

### 컴파운딩 엔지니어링 — 복리의 관점

반복되는 20분 루틴을 2분 스킬로 만드는 것, MEMORY.md에
매일 기록하는 것, 실패 패턴을 KNOWN_ISSUES.md로 축적하는
것 — 이 모든 것이 복리로 돌아온다. 하루의 효과는
미미하지만 3개월이 지나면 격차가 벌어진다.

이 관점이 에이전틱 엔지니어링을 단순한 도구 활용이 아닌
**엔지니어링 습관의 체계**로 격상시킨다. 도구는 바뀌어도
습관은 남는다.

### "에이전트 친화적 코드"라는 새로운 품질 기준

Ronacher의 "도구는 LLM 카오스 원숭이가 완전히 잘못 쓰는
것에 대비해야 한다"는 관점이 흥미롭다. Makefile에
프로세스 이중 실행 방지, 포트 충돌 예방을 넣는 것.
이제 코드 품질에 **에이전트가 실수할 여지를 줄이는
구조**라는 새로운 차원이 추가된다.

역설적이지만, 코드를 읽지 않는 시대에 코드 품질이 오히려
더 중요해졌다. 에이전트가 잘 작동하는 환경 = 잘 설계된
코드베이스 = 사람이 읽기 쉬운 코드. 에이전트 친화성과
인간 친화성은 놀랍도록 일치한다.

### 실패 분류 체계의 실용적 가치

실패를 "컨텍스트 부족 / 방향 오류 / 구조적 충돌"로
분류하는 프레임워크가 즉시 적용 가능하다. "다시 해봐"를
누르는 대신 "이건 어떤 유형이지?"를 먼저 생각하는 것.
이 한 단계의 메타인지가 복구 속도를 극적으로 높인다.

특히 "Must NOT Have" 가드레일 패턴 — 에이전트에게 해야
할 것보다 **하지 말아야 할 것**을 명시하는 것이 종종 더
효과적이다. 자유도를 제한해서 탐색 공간을 좁히는 원리다.

### 소크라틱 인터뷰: 인간과 AI의 새로운 협업 패턴

구현 전에 AI에게 질문을 받는 5분이 구현 후 4시간
핑퐁을 아낀다. 이것은 단순한 팁이 아니라 협업 패러다임의
전환이다. AI를 "시키는 대상"이 아니라 "생각을 정리하는
파트너"로 전환하는 것. 요구사항의 빈틈을 코드가 아닌
대화로 먼저 발견한다.

이 패턴은 에이전트의 생산성을 극대화하는 동시에 인간의
사고력도 강화한다. AI가 질문을 던지면 "내가 뭘 원하는지"
를 명확히 정리하게 되기 때문이다. **AI의 가장 큰
가치는 답이 아니라 질문에 있을 수 있다.**

### 매니저 경험의 재평가

CTO/매니저 경험이 에이전트 시대에 직접적 경쟁력이
된다는 통찰이 시사하는 바가 크다. 기술 관리자 경력이
"코딩에서 멀어진 시간"이 아니라 "오케스트레이션 감각을
키운 시간"으로 재평가될 수 있다. 스쿼드 관리에서 익힌
체크포인트 설계, 블로커 해결, 방향 조율 능력이 에이전트
시대의 핵심 역량과 정확히 겹친다.

## 관련 문서

- [Agentic Engineering Patterns #1-1: Code Is Cheap](./agentic-engineering-patterns-1-1-code-is-cheap.md)
- [Agentic Engineering Patterns #2-1: Red/Green TDD](./agentic-engineering-patterns-2-1-red-green-tdd.md)
- [Agentic Software Levels](./agentic-software-levels.md)
- [Karpathy's Claude Coding Notes](./karpathy-claude-coding-notes.md)
- [Spec-Driven Development](./spec-driven-development.md)
- [AI Coding Agent Guidelines](./ai-coding-agent-guidelines.md)
