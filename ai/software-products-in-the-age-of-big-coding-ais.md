# 거대 코딩 AI 시대의 소프트웨어 제품

원문: Ramin (@ramin_m_h) -
Software Products in The Age of Big Coding AIs

## 패러다임 전환

2020년 이후 코딩 AI는 빠르게 진화했다:

- IDE 자동완성 → 설명 기반 함수 작성
- → Claude Code, Cursor, Devin, Replit, Codex 등
  자율적 코딩 에이전트의 등장

현재 대부분의 코딩 에이전트는 **반응형(reactive)**이다.
사용자가 작업을 설명하고, LLM이 응답하고,
사용자가 후속 요청을 보내는 루프를 반복한다.

## 거대 코딩 AI의 방향

Opus 4.6, GPT 5.3 Codex 등 최신 모델은
**완전 자율(full autonomy)**에 초점을 맞추고 있다.
복잡한 프로젝트 전체를 제로샷으로 생성하려 한다.

두 가지 접근 방식이 있다:

1. **서브에이전트 분할** -
   문제를 여러 하위 문제로 나누고,
   도구/스킬/메모리에 접근 가능한 서브에이전트가 각각
   자신의 컨텍스트 한도 내에서 해결
2. **재귀적 언어 모델(RLM)** -
   제한된 컨텍스트 길이를 귀중하게 다루며,
   재귀적 작업 할당과 메모리 읽기/쓰기를 통해
   이론적으로 무한한 컨텍스트 길이를 처리

그러나 [1인간 + 1에이전트](./one-human-one-agent.md)
실험이 보여줬듯,
에이전트를 늘린다고 결과가 좋아지지는 않는다.
수백 개 서브에이전트 스웜보다
인간 한 명이 전략을 잡고
에이전트 한 대가 실행에 집중하는 구조가
더 나은 결과를 내는 경우가 많다.
완전 자율의 방향이 맞더라도,
**조정 비용(coordination cost)**을 무시할 수 없다.

## SaaS의 본질 변화

이 흐름은 SaaS의 본질에도 영향을 준다.

- 인간 오퍼레이터용 UI에서
  **에이전트가 소프트웨어를 조작하는 형태**로 전환
- 에이전트가 직접 서비스를 구축하거나,
  서드파티 서비스 및 API와 상호작용
- **모듈화(Modularization)**가 핵심
- 가격 모델도 시트 기반 라이선싱에서
  **소비/성과 기반**으로 변화

제품 설계 시 **에이전트, 인간 오퍼레이터,
클라이언트 이해관계자** 세 사용자를
동시에 고려해야 한다.
이는 API 설계, UI/UX, 가격 모델 모두에
근본적 변화를 요구한다.
에이전트가 호출할 수 있는 API,
인간이 감독할 수 있는 대시보드,
이해관계자가 성과를 확인할 수 있는 리포트가
하나의 제품 안에 공존해야 한다.

## 개발 방식의 변화

**1) 코딩 = 오케스트레이션 + 테스트 + 검증.**
에이전트가 코드를 작성하지만,
인간은 **무엇을 만들지 선택**하고,
**제약을 정의**하고,
**실제 세계에서 작동함을 증명**한다.
인간 프로그래밍의 핵심은
실행 가능한 PRD와 예시 구현 설계,
그리고 명확한 테스트와 피드백 루프가 된다.
프로그래머의 역할이 "코드를 작성하는 사람"에서
**"무엇을 만들지 결정하고,
에이전트의 출력을 검증하는 사람"**으로 전환된다.
이는 [Spec-Driven Development](./spec-driven-development.md)의
"명세가 단일 정보원(source of truth)"이라는
사상과 정확히 일치한다.
SDD에서 명세가 실행 가능한 계약이듯,
여기서도 PRD가 실행 가능한 코드가 된다.

**2) BIG SLOP에 주의하라.**
오늘날 AI가 생성한 코드는
프론트엔드 디자인을 넘어서면
**비효율적이고 엉성한(sloppy)** 경우가 많다.
AI 코드 생성의 품질 문제를
"BIG SLOP"이라 명명한 것이
문제의 규모를 잘 드러낸다.
[Vibe Coding](./vibe-coding.md)의 편리함에 취해
리뷰 없이 코드를 밀어넣으면
기술 부채가 기하급수적으로 쌓인다.
**코드 리뷰와 성능 검증이
그 어느 때보다 중요하다.**

**3) 브레인스토밍 시 효율적 코드 예시를 제공하라.**
AI 에이전트와 더 빠르게 수렴하려면,
세션 시작 시 효율적인 코드 예시를 먼저 제공하라.
CLAUDE.md나 커서룰 같은 에이전트 설정 파일에
코드 스타일과 예시를 포함시키는 것이
실질적인 실천 방법이다.

**4) 기존 기능 보호 지침을 명시하라.**
AI는 현재 작업의 지시사항만 엄격히 따르는 경향이 있어,
이전에 구현한 기능을 무시하거나 덮어쓸 수 있다.
복잡한 다단계 프로토타이핑에서는
**이전 기능을 보호하는 지침을 연결(chain)**하라.
테스트 커버리지가 이 보호막의 핵심이다.
"이 테스트가 깨지면 안 된다"는 제약이
에이전트에게 가장 명확한 지침이 된다.

## 조직이 바꿔야 할 것

**1) 모든 기술 명세와 PRD를 코드로 전환하라.**
인간용 기술 명세가 이렇다면:

> 오디오 함수 호출은 Snapdragon X/ARM 노트북에서
> p95 응답시간 100ms 미만이어야 한다.

기계용 코드 버전은 이렇다:

- 각 대상 디바이스에서 실행되는 벤치마크 하네스
- CI에서 p95 > 100ms이면 실패 처리

기술 명세를 단순한 문서가 아니라
**벤치마크 하네스와 CI 게이트가 포함된
실행 가능한 코드**로 전환하라는 것이 핵심이다.
이는 단순히 개발 방식의 변화가 아니라,
**조직 문화의 근본적 전환**을 요구한다.
"문서를 쓰고 회의하는" 문화에서
"코드로 계약하고 CI로 검증하는" 문화로의 이동이다.

**2) 테스트와 평가가 주요 초점이다.**
하네스를 **제품 인프라**로 취급하라.

**3) 에이전트 친화적 출력을 구조화하라.**
에이전트는 "시간 개념이 없고(time-blind)"
컨텍스트가 제한적이다.
빌드/테스트 출력, 로그, 문서를
**기계 파싱에 적합하게 구조화**하라.

**4) 코드 성능 리뷰 포맷을 통일하라.**
비효율적 코드를 다루기 위한
통일된 성능 리뷰 형식을 갖추라.
BIG SLOP을 조직 차원에서 방어하려면
자동화된 성능 게이트가 필수다.

## 무엇을 만들어야 하는가

다음 제품은 높은 **대체 위험(disruption risk)**에
노출된다:

- 프롬프트 템플릿 모음
- 범용 플래너/오케스트레이터
- 도구 호출의 얇은 래퍼(thin wrapper)
- 에이전트 실행용 UI

거대 AI가 이런 기능을 자체적으로 해결할 수 있기 때문이다.
살아남는 제품은
**AI가 스스로 대체할 수 없는 전문 영역**에 있다.

대신 **에이전트, 인간 오퍼레이터, 클라이언트 이해관계자**
세 사용자를 동시에 지원하는 제품을 만들어야 한다:

**1) AI 검증 도구.**
AI의 중간 출력과 결정을 검증하는 도구.
에이전트 평가, 동적 테스트 파이프라인,
시뮬레이션 환경 + 골든 데이터셋.
**AI 실행에 대한 신뢰와 확신을 높이는 소프트웨어.**
에이전트가 코드를 많이 쓸수록 검증 수요도 폭발한다.
이 영역은 AI가 발전할수록 오히려 가치가 커진다.

**2) 에이전트 파싱 가능한 인프라 전환 도구.**
레거시 기업의 내부 프로세스와 데이터 파이프라인을
**에이전트가 파싱할 수 있는 형태**로 전환하는 도구.
대부분의 기업은
아직 에이전트 시대의 인프라를 갖추지 못했다.
PDF, 스프레드시트, 사내 위키에 갇힌 지식을
구조화된 API와 데이터로 전환하는 것만으로도
거대한 시장이 열린다.

**3) 제약 기반 컴퓨트 / 디바이스 AI.**
물리 법칙과 규제가 중요한 영역:
저지연, 에어갭 런타임, 하드웨어 인식 벤치마킹,
플릿 롤아웃/롤백, 디바이스 정책, 텔레메트리.
클라우드 API 호출로는 해결할 수 없는 물리적 제약이
이 영역의 해자(moat)다.

**4) 과학용 AI 소프트웨어.**
예측 의학, 신약 발견, 수학/물리학 프론티어,
에너지, 재료 과학을 위한 특화 파운데이션 모델.

**5) 인간 참여형(Human-in-the-Loop) 소프트웨어.**
인간 전문가, 검증자, 운영자를 루프에 유지하도록
설계된 제품.
의사결정이 중요한 애플리케이션에서
AI 시스템의 신뢰성을 높이기 위한
데이터, RL, 시뮬레이션 환경.

## 관련 문서

- [Spec-Driven Development](./spec-driven-development.md)
- [AI Agent](./agent.md)
- [One Human + One Agent](./one-human-one-agent.md)
- [Vibe Coding](./vibe-coding.md)
