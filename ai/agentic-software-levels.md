# 에이전틱 소프트웨어의 5단계

Ashpreet Bedi의 트윗 (2026년 2월):
<https://twitter.com/ashpreetbedi/status/2024885969250394191>

Agno 창업자가 코딩 에이전트 Gcode를 예시로 에이전틱 소프트웨어의
아키텍처 단계를 정리한 글.

- [Agno GitHub](https://github.com/agno-agi/agno)
- [Agno Docs](https://docs.agno.com)

## 핵심 메시지

대부분의 팀은 멀티 에이전트 오케스트레이션, 자율 추론 루프, 과한
인프라로 에이전트를 과도하게 복잡하게 만든다. 그리고 가장 단순한
작업이 왜 실패하는지 디버깅하는 데 몇 주를 보낸다.

패턴은 단순하다: 단순하게 시작하고, 단계적으로 기능을 추가하고,
매 단계에서 동작을 검증한다.

## Level 1: 도구를 갖춘 에이전트

도구 없는 에이전트는 그냥 LLM이다. 추론은 할 수 있지만 아무것도
할 수 없다. 도구야말로 LLM을 에이전트로 만드는 것이다.

코딩 에이전트를 위한 최소 도구셋: 파일 읽기, 파일 쓰기, 셸 명령 실행.

```python
agent = Agent(
    name="Gcode",
    model=OpenAIResponses(id="gpt-5.2"),
    tools=[CodingTools(base_dir=WORKSPACE, all=True)],
)
```

**한계:** 매 실행마다 제로에서 시작한다. 이전 세션을 기억하지 못하고,
프로젝트 관례를 프롬프트에 붙여넣지 않으면 따를 수 없다.

## Level 2: 저장소와 지식을 갖춘 에이전트

Level 1은 무상태(stateless)다. Level 2는 두 가지를 추가한다.

**저장소(Storage):** 모든 에이전트 세션과 실행 기록을 DB에 저장한다.
대화 이력을 컨텍스트로 활용하고, 자체 데이터로 감사·쿼리가 가능하다.

**지식(Knowledge):** 오늘날 코딩 에이전트는 코드베이스만 본다.
아키텍처 명세, 팀의 설계 결정, 내부 회의 노트, "왜 DynamoDB 대신
Postgres를 선택했는가" 같은 슬랙 스레드는 보지 못한다.

핵심 통찰: **가치 있는 컨텍스트의 상당 부분은 코드베이스 밖에 있다.**
한 달 전 회의에서 논의된 마이그레이션 전략이나, 6개월 전에 라이브러리
X를 선택한 이유 등. 이를 지식베이스에 주입하면 에이전트가 맥락에 맞는
결정을 내릴 수 있다.

```python
agent = Agent(
    knowledge=knowledge,        # ChromaDb (hybrid search)
    search_knowledge=True,
    db=db,                      # SqliteDb
    add_history_to_context=True,
    num_history_runs=3,
)
```

**사용 시점:** 에이전트가 학습되지 않은 표준을 따라야 하거나, 멀티턴
대화가 필요할 때. 대부분의 내부 도구에서 최적의 균형점.

## Level 3: 메모리와 학습을 갖춘 에이전트

Level 2에서 3으로의 도약이 가장 중요하다.
Level 2는 주어진 규칙을 따른다. Level 3은 경험에서 규칙을 학습한다.

**1000번째 인터랙션은 1번째보다 나아야 한다.**

- **학습 머신(Learning Machine):** 에이전트가 기억할 가치가 있는 것을
  스스로 결정한다. 잘 작동한 코딩 패턴, 피해야 할 실수, 사용자 선호도를
  별도 지식베이스에 저장해 이후 세션에서 활용한다.
- **에이전틱 메모리:** 시간이 지남에 따라 사용자 프로필을 구축한다.
  선호하는 코딩 스타일, 사용하는 프레임워크, 설명 방식 선호도 등.

2세션 테스트:

```python
# 세션 1: 사용자가 선호도를 가르침
agent.print_response(
    "함수형 프로그래밍 스타일을 선호합니다. 데이터 파이프라인을 작성해주세요.",
    session_id="session_1",
)

# 세션 2: 새 작업 - 에이전트가 선호도를 적용
agent.print_response(
    "로그 파서를 작성해주세요.",
    session_id="session_2",  # 자동으로 함수형 스타일로 작성
)
```

**사용 시점:** 같은 사용자에게 반복적으로 서비스하고, 시간이 지남에
따라 개선되어야 할 때.

## Level 4: 멀티 에이전트 팀

때로는 에이전트 하나로 충분하지 않다. Level 4는 팀 리더가 조율하는
전문화된 에이전트들로 책임을 분리한다.

| 에이전트     | 역할               | 제한                         |
| ------------ | ------------------ | ---------------------------- |
| Coder        | 코드 작성          | 없음 (전체 도구)             |
| Reviewer     | 코드 리뷰          | 쓰기/편집/셸 비활성화        |
| Tester       | 테스트 작성 및 실행 | 없음 (전체 도구)             |

**솔직한 주의사항:** 팀 리더도 LLM이라 위임 결정이 들쑥날쑥하다.
신뢰성이 중요한 프로덕션 시스템에서는 **동적 팀 대신 명시적
워크플로우를 선호하라.** 팀은 사람이 감독할 수 있는 환경에서 빛난다.

**사용 시점:** 코드 리뷰처럼 다양한 관점이 필요하거나, 작업이 자연스럽게
전문 역할로 분해될 때.

## Level 5: 프로덕션 에이전틱 시스템

Level 1~4를 프로덕션 서비스로 전환하는 런타임이다.

| 개발 환경      | 프로덕션 환경                    |
| -------------- | -------------------------------- |
| SqliteDb       | PostgresDb                       |
| ChromaDb       | PgVector (커넥션 풀링, 백업)     |
| 로컬 실행      | AgentOS (FastAPI + 웹 UI + 추적) |

```python
agent_os = AgentOS(
    agents=[coding_agent],
    teams=[coding_team],
    tracing=True,  # 모든 도구 호출, 지식 검색, 위임 결정 관측
)
app = agent_os.get_app()
```

**사용 시점:** 에이전트가 노트북을 떠날 때. 다수 사용자, 업타임
요구사항, 프로덕션 이슈 디버깅 필요성이 생겼을 때.

## 가장 중요한 조언

**Level 1에서 시작하라.** 문제를 해결할 수 있는 가장 단순한 에이전트를
만들어라. 실행하고, 어디서 실패하는지 보고, 빠진 기능만 정확히 추가하라.

대부분의 팀은 멀티 에이전트 아키텍처가 데모에서 인상적으로 보이기 때문에
Level 4로 건너뛴다. 그리고 단일 에이전트에 좋은 지시문만 있었어도 피할 수
있었던 조율 실패를 몇 달 동안 디버깅한다.

각 레벨은 복잡성을 추가한다. 복잡성에는 비용이 따른다.
**단순한 방법이 명백히 실패했을 때만 다음 레벨로 이동하라.**

## 인사이트

### "단순하게 시작하라"는 말은 항상 옳다

이 프레임워크의 핵심 메시지는 소프트웨어 개발의 고전 원칙과 같다: YAGNI.
멀티 에이전트 시스템은 단일 에이전트가 실패하는 곳에서만 빛난다. 많은
팀이 "인상적으로 보이는 아키텍처"를 위해 불필요한 복잡성을 선택한다.

### Level 3의 학습이 진짜 게임 체인저

Level 2와 3의 차이가 가장 크다. "규칙을 따르는 것"과 "규칙을 학습하는 것"의
차이는 도구와 동료의 차이다. 상호작용이 쌓일수록 나아진다는 것은 에이전트가
단순한 도구가 아닌 **협업 파트너**로 진화함을 의미한다.

### 멀티 에이전트에 대한 솔직한 경고

저자가 Level 4에서 직접 "예측하기 어렵다"고 경고하는 점이 인상적이다.
대부분의 에이전트 프레임워크 소개 글은 멀티 에이전트를 이상적인 목표로
그린다. 그러나 **프로덕션에서는 명시적 워크플로우가 더 신뢰성이 높다**는
현실적 조언은 귀중하다.

### 코드베이스 밖의 컨텍스트

Level 2에서 강조하는 "지식"의 개념은 자주 간과된다. 코딩 에이전트를 도입할
때 많은 팀이 코드만 제공한다. 하지만 "왜 이 결정을 내렸는가", "팀의 설계
철학은 무엇인가"가 담긴 문서를 지식베이스에 주입하면 에이전트의 판단 품질이
근본적으로 달라진다.

### 이 프레임워크의 범용성

Agno 라이브러리를 소개하는 글이지만, 프레임워크 독립적인 개념으로도 충분히
유효하다. **레벨 → 기능 추가 → 검증**의 점진적 접근법은 어떤 에이전트
스택에도 적용할 수 있는 사고 모델이다.

## 관련 문서

- [AI Agent](./agent.md)
- [Golbin Agent Prompting Flow](./golbin-agent-prompting-flow.md)
- [Karpathy's Claude Coding Notes](./karpathy-claude-coding-notes.md)
