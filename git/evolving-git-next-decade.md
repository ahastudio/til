원문: <https://lwn.net/SubscriberLink/1057561/bddc1e61152fadf6/>

# Git의 다음 10년: 전환 포인트와 체크리스트

## 요약

Git은 혁명보다 점진적 진화로 다음 10년을 준비하고 있다.
핵심 축은 SHA-256 전환, reftable 기본화, 대용량 바이너리 처리 개선,
그리고 UI 현대화다.

## 인사이트

### 1) 기능 추가보다 기본값 전환이 더 큰 변화다

Git 3.0의 파급력은 신규 기능 그 자체보다 기본값 변경에 있다.
SHA-256과 reftable이 기본이 되면 기존 자동화와 운영 관행이 직접적인
영향을 받는다.

### 2) 진짜 리스크는 Git 코어 밖에 있다

장애 가능성은 Git 자체보다 주변 생태계에서 더 자주 발생한다.
CI 스크립트, 릴리스 봇, 내부 도구가 SHA-1 길이나 refs 파일 구조를
고정 가정하면 전환 시 문제를 일으킬 수 있다.

### 3) 바이너리 이슈는 성능이 아니라 비용 구조의 문제다

대형 바이너리 처리는 개발 편의만의 문제가 아니다.
스토리지, 전송, 서버 유지 비용에 직접 연결되므로 large-object promisor와
객체 저장소 분리는 인프라 원가 구조를 바꿀 수 있다.

### 4) UI 개선은 명령어 추가가 아니라 작업 방식 변화다

Jujutsu에서 받은 자극은 문법 흉내가 아니라 작업 철학의 변화다.
커밋을 완성품이 아닌 수정 가능한 초안으로 다루는 접근이 확산되면,
코드리뷰와 브랜치 전략 자체도 달라질 수 있다.

## 실무 체크리스트

### P0: 2주 내 착수

- 조직 내 Git 사용 경로를 인벤토리로 정리한다.
- CI, 배포, 릴리스 자동화에서 SHA-1 고정 가정을 찾는다.
- `.git/refs` 또는 `packed-refs` 직접 접근 로직을 식별한다.
- 사용 중인 포지와 서드파티 도구의 SHA-256 지원 상태를 기록한다.

### P1: 1개월 내 방어선 구축

- refs 접근을 파일 파싱에서 Git 명령 기반으로 전환한다.
- 해시 길이와 알고리즘 하드코딩을 제거한다.
- 전환 관련 회귀 테스트를 CI에 추가한다.
- 대형 바이너리 저장 원칙을 문서화한다.

### P2: 분기 단위 리허설

- 샌드박스 프로젝트에서 SHA-256 신규 리포를 시험 운영한다.
- reftable 기반 리포를 만들어 내부 도구 호환성을 점검한다.
- partial clone과 promisor 적용 후보를 선정한다.
- 장애 시 롤백 절차를 운영 문서로 정리한다.

### P3: 조직 운영 제도화

- 개발 표준에 해시 알고리즘 비종속 원칙을 반영한다.
- refs 파일 직접 접근 금지 규칙을 명문화한다.
- 포지 로드맵과 내부 플랫폼 로드맵을 분기마다 동기화한다.
- 히스토리 편집 중심 워크플로우 교육을 정기 운영한다.

## 빠른 자가진단

- 우리 CI 스크립트에 SHA-1 길이 가정이 남아 있는가.
- refs 파일을 직접 읽는 내부 스크립트가 존재하는가.
- 팀, 러너, 서버의 Git 버전 정책이 통일되어 있는가.
- 포지의 SHA-256 및 reftable 지원 일정이 확인되어 있는가.
- 대형 바이너리 취급 기준과 예외 절차가 문서화되어 있는가.
- 전환 실패 시 우회 경로와 롤백 절차가 점검되어 있는가.
