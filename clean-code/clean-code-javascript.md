# Clean Code JavaScript

<https://github.com/ryanmcdermott/clean-code-javascript>

Robert C. Martin의 *Clean Code* 원칙을 JavaScript에 적용한
가이드. "읽기 쉽고, 재사용 가능하고, 리팩터링 가능한" 코드를
목표로 한다.

## 요약

변수, 함수, 객체/자료구조, 클래스, SOLID, 테스트,
동시성, 에러 처리, 포맷팅, 주석의 10개 영역을 다룬다.
각 영역마다 Bad/Good 코드 예시를 제시하며,
"규칙"이 아니라 "가이드라인"임을 강조한다.

| 영역             | 핵심 메시지                       |
|------------------|-----------------------------------|
| 변수             | 이름이 의도를 드러내야 한다       |
| 함수             | 하나의 일만, 인자는 2개 이하      |
| 객체/자료구조    | getter/setter로 캡슐화           |
| 클래스           | ES6 class, 합성 우선              |
| SOLID            | 5원칙의 JS 실전 적용              |
| 테스트           | 테스트 하나에 개념 하나           |
| 동시성           | Promise → async/await             |
| 에러 처리        | 에러를 삼키지 마라                |
| 포맷팅           | 호출자와 피호출자를 가까이        |
| 주석             | 코드로 표현하라, 주석은 최후 수단 |

## 인사이트

### 코드는 사람에게 보내는 편지다

이 가이드의 모든 원칙을 관통하는 전제가 하나 있다.
**코드는 작성되는 것보다 읽히는 횟수가 압도적으로 많다.**
변수 이름, 함수 이름, 포맷팅, 주석 — 가이드가 다루는
거의 모든 영역이 "읽는 사람"을 향해 있다.

그런데 "읽는 사람"이 누구인가? 대부분 미래의 나 자신이다.
6개월 뒤의 나는 오늘의 맥락을 기억하지 못한다.
`d`라는 변수명을 쓴 나는 그것이 경과 일수라는 것을
알지만, 6개월 뒤의 나는 모른다.
`elapsedTimeInDays`라고 쓰는 것은 미래의 나에게
보내는 편지다.

이름 짓기가 어려운 이유는 그것이 본질적으로
**설계 행위**이기 때문이다. 이름을 잘 못 짓겠다면
대상을 충분히 이해하지 못한 것이다.
좋은 이름이 떠오르는 순간은
설계가 명확해지는 순간과 일치한다.

### 작은 것이 합성 가능하다

함수 인자를 2개 이하로 제한하라. 함수는 한 가지 일만
하라. 플래그 인자를 쓰지 마라. — 이런 규칙들을 따로
보면 "코딩 스타일" 정도로 느껴진다.
하지만 이것들이 가리키는 방향은 하나다:
**작은 단위는 합성할 수 있다.**

`createFile(name, temp)`는 두 가지 일을 하는 함수다.
`createFile(name)`과 `createTempFile(name)`으로
나누면 각각은 독립적으로 테스트할 수 있고,
다른 흐름에서 재사용할 수 있고,
이름만으로 의도가 드러난다.

레고 블록이 강력한 이유는 블록 하나가 단순하기
때문이다. 블록 하나가 집이면서 동시에 자동차인
레고는 존재하지 않는다.
함수도 마찬가지다. 한 가지 일만 하는 함수는
어디에든 끼워 맞출 수 있다.

이것은 SOLID의 단일 책임 원칙(SRP)과도 직결된다.
클래스든 함수든, 변경의 이유가 하나뿐인 단위는
변경의 영향 범위가 예측 가능하다.
예측 가능한 변경이 쌓이면 시스템 전체가 다루기 쉬워진다.

### 부수 효과는 프로그래밍의 본질적 긴장이다

순수 함수는 아름답다. 같은 입력에 항상 같은 출력.
테스트하기 쉽고, 추론하기 쉽다.
그런데 프로그램이 존재하는 이유는 결국
**세상에 부수 효과를 일으키기 위해서다.**
파일을 저장하고, 화면에 그리고, 네트워크로 보낸다.
부수 효과가 없는 프로그램은 의미가 없다.

이 가이드가 말하는 것은 부수 효과를 없애라가 아니다.
**부수 효과가 일어나는 지점을 한곳으로 모으라**는 것이다.
Gary Bernhardt가 말한 "Functional Core,
Imperative Shell" 패턴이 바로 이것이다.
비즈니스 로직은 순수하게, 외부 세계와의 접점은
명시적인 경계에서만 처리한다.

부수 효과가 코드 전체에 흩어져 있으면
"이 함수를 호출하면 무슨 일이 벌어지지?"라는
질문에 답하기 위해 호출 트리 전체를 추적해야 한다.
경계가 명확하면 "여기까지는 안전하고,
여기서부터 바깥 세상과 대화한다"고 말할 수 있다.

### 추상화 수준을 섞지 마라 — 글쓰기와 같다

하나의 함수 안에서 `getActiveUsers()`를 호출하면서
바로 다음 줄에서 `response.body.split('\n')`을 하면,
읽는 사람은 두 가지 다른 해상도를 동시에 처리해야 한다.
이것은 마치 전략 보고서 중간에 갑자기
TCP 패킷의 바이트 구조를 설명하는 것과 같다.

좋은 글이 문단마다 일관된 추상화 수준을 유지하듯,
좋은 함수도 한 수준에서만 이야기한다.
고수준 함수는 "무엇을" 하는지 말하고,
저수준 함수는 "어떻게" 하는지 말한다.
둘을 섞는 순간 독자는 길을 잃는다.

이것은 함수 추출의 핵심 판단 기준이기도 하다.
"이 코드가 너무 길어서" 함수를 나누는 것이 아니라,
**추상화 수준이 다른 코드가 섞여 있어서** 나누는 것이다.
길이는 결과일 뿐, 원인이 아니다.

### 상속의 유혹을 경계하라

가이드는 is-a 관계에만 상속을 쓰라고 말한다.
하지만 진짜 교훈은 더 깊은 곳에 있다.
**is-a 관계라고 생각한 것이 실은 has-a인 경우가
대부분이라는 것이다.**

"군인은 사람이다"는 맞지만,
"군인 클래스가 사람 클래스를 상속한다"가
좋은 설계인 것은 아니다.
군인은 "군인 역할을 가진 사람"일 수 있고,
나중에 "퇴역 군인"이 되거나 "예비역"이 될 수 있다.
상속은 컴파일 타임에 관계를 고정하지만,
합성은 런타임에 관계를 바꿀 수 있다.

상속이 만드는 진짜 문제는 **변경의 전파**다.
부모 클래스를 바꾸면 모든 자식이 영향받는다.
이것은 SOLID의 개방-폐쇄 원칙(OCP)을 정면으로
위반한다. 합성은 이 결합을 끊어낸다.

### 에러 처리는 설계의 일부다

```javascript
// 흔한 풍경
try {
  doSomething();
} catch (error) {
  console.log(error);
}
```

이 패턴이 만연한 이유는 에러 처리를 "나중에 할 일"로
생각하기 때문이다. 하지만 에러가 발생했을 때
시스템이 어떻게 반응하느냐는 정상 동작만큼 중요한
**설계 결정**이다.

`console.log`만 하면 에러는 로그의 바다에 빠져
사라진다. 에러를 잡았다면 세 가지 중 하나를 하라:
복구하거나, 사용자에게 알리거나, 모니터링 시스템에
보고하거나. 이 셋 중 아무것도 하지 않을 거라면
차라리 에러를 잡지 않는 것이 낫다.
잡지 않은 에러는 최소한 시끄럽게 죽어서
문제가 있다는 것을 알려준다.

### 삭제의 용기 — 클린 코드의 숨은 전제

죽은 코드를 남기고, 주석 처리된 코드를 보존하고,
"혹시 모르니까" 유틸 함수를 만들어두는 것.
이 모든 행동의 뿌리는 **변경에 대한 두려움**이다.
"나중에 필요하면 어쩌지?"
"삭제했다가 문제가 생기면?"

클린 코드의 모든 원칙 — 좋은 이름, 작은 함수,
테스트, SOLID — 은 궁극적으로
**코드를 변경할 용기를 주기 위해** 존재한다.
테스트가 있으면 삭제해도 안전한지 바로 확인할 수 있다.
작은 함수는 영향 범위가 명확하다.
버전 관리가 있으니 언제든 되살릴 수 있다.

Ward Cunningham의 기술 부채 비유도 같은 이야기다.
클린 코드를 유지해야 나중에 리팩터링할 수 있고,
리팩터링할 수 있어야 이해가 깊어지고,
이해가 깊어져야 더 나은 코드를 쓸 수 있다.

### 클린 코드는 목적지가 아니라 방향이다

> Not all code has to be perfect when it is first written.

이 가이드의 마지막 문장이 가장 중요하다.
가이드 전체를 읽고 "이 모든 것을 한 번에
지켜야 한다"고 느꼈다면, 그것은 오독이다.

첫 번째 드래프트는 절대 깨끗하지 않다.
글쓰기에서 초고가 엉망인 것이 자연스럽듯,
코드의 첫 버전도 엉망인 것이 자연스럽다.
중요한 것은 **첫 번째 코드를 완벽하게 쓰는 것**이
아니라 **리팩터링을 통해 점진적으로 개선하는 것**이다.

클린 코드는 상태가 아니라 과정이다.
코드 리뷰에서 동료가 더 나은 이름을 제안하고,
테스트를 작성하면서 함수를 분리하고,
버그를 고치면서 에러 처리를 개선한다.
이 반복이 클린 코드다.
