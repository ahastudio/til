# GitNexus

GitNexus는 서버 없이 브라우저에서 동작하는 코드 인텔리전스 도구다.
GitHub 저장소 URL 또는 ZIP 파일을 넣으면 코드 지식 그래프와
Graph RAG 에이전트를 생성해 코드 탐색을 돕는다.

- 프로젝트: <https://github.com/abhigyanpatwari/GitNexus>
- 포지셔닝: Zero-Server Code Intelligence Engine

## 한눈에 보는 가치

- **프라이버시 우선**: 서버 업로드 없이 클라이언트에서 분석 가능
- **탐색 속도 개선**: 파일 트리 탐색을 그래프 탐색으로 확장
- **온보딩 가속**: 신규 기여자가 의존 관계를 시각적으로 이해 가능
- **질의형 이해**: Graph RAG로 "어디를 먼저 읽어야 하는가"에 답변 가능

## 분석 관점에서 보는 핵심 파이프라인

GitNexus 류 도구를 평가할 때는 아래 파이프라인을 기준으로 보면 좋다.

1. **Ingestion(수집)**
   - GitHub URL/ZIP 입력을 받아 로컬 메모리로 로드
   - 대용량 저장소일수록 초기 파싱 비용이 커짐
2. **Parsing(구문 분석)**
   - 파일별 심볼, 참조, import/호출 관계 추출
   - 정확도는 언어 지원 범위와 파서 성숙도에 좌우됨
3. **Graph Build(그래프 생성)**
   - 노드(파일/심볼)와 엣지(참조/호출) 구성
   - 중복 심볼 처리와 네임스페이스 충돌 처리가 중요
4. **Retrieval + Reasoning(Graph RAG)**
   - 질문을 그래프 탐색 경로로 변환해 관련 맥락 회수
   - 텍스트 검색 + 그래프 인접성 결합 품질이 핵심
5. **Visualization(UI)**
   - 서브그래프 필터링, 줌/팬, 노드 강조 기능이 생산성 좌우

## 코드 분석 인사이트

### 1) "정확도"는 모델보다 파서가 먼저 결정한다

Graph RAG 품질은 LLM 이전에 그래프의 사실성에서 결정된다.
파서가 심볼 관계를 놓치면, 답변은 그럴듯해도 근거가 빈약해진다.

### 2) 모노레포에서는 "범위 제한"이 필수다

전체 그래프를 한 번에 그리면 노이즈가 커진다.
도메인(패키지), 레이어(API/서비스/저장소), 변경 이력 기준으로
서브그래프를 나눠야 실무에서 쓸 수 있다.

### 3) 온보딩/리뷰 시나리오에 특히 강하다

- 온보딩: 핵심 엔트리포인트 → 의존 모듈 경로를 빠르게 제시
- 코드리뷰: 변경 파일 주변 영향 반경(impact radius) 시각화
- 장애 대응: 에러 발생 모듈의 상·하위 호출 관계 즉시 확인

### 4) 보안·규제 환경에서 차별점이 크다

클라이언트 사이드 실행은 "코드를 외부 서버에 올리기 어려운"
조직에서 도입 장벽을 낮춘다.

## 실무 도입 체크리스트

- 분석 대상 언어가 실제로 지원되는지 확인
- 대규모 저장소에서 브라우저 메모리 한계 측정
- 그래프 결과를 IDE 탐색 흐름과 연결할 방법 준비
- 팀 공통 질문 템플릿(예: "핵심 진입점")을 사전 정의
- 결과 검증 규칙(샘플 수동 검증) 운영

## 한계와 주의사항

- 동적 디스패치, 메타프로그래밍, 리플렉션 코드는 정적 분석 난이도 높음
- 생성 그래프를 절대 정답으로 보면 오판 가능
- 브라우저 리소스 한계로 초대형 저장소는 분할 분석이 필요할 수 있음

## 추천 활용 패턴

1. 먼저 작은 서비스 저장소로 파이프라인 검증
2. 팀의 반복 질문 10개를 고정 프롬프트로 표준화
3. PR 리뷰 템플릿에 그래프 기반 영향 분석 섹션 추가
4. 분기마다 파서 정확도 샘플 테스트로 품질 관리
