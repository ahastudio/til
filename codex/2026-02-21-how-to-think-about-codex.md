# Codex를 이해하는 방법

- 출처: [How I Think About Codex][tweet]
- 저자: Gabriel Chua (@gabrielchua) · 2026년 2월 21일

[tweet]: https://twitter.com/gabrielchua/status/2025017553442201807

---

## 핵심 요약: Codex = Model + Harness + Surfaces

"Codex"는 맥락에 따라 모델, 앱, 에이전트 등 다른 것을
가리킨다.

Gabriel Chua의 멘탈 모델:

```
Codex = Model + Harness + Surfaces
```

- **Model + Harness = 에이전트 자체**
- **Surfaces = 에이전트와 상호작용하는 방법**

---

## 모델(Model): 소프트웨어 공학 특화 지능

단순한 코드 자동완성이 아니라 **추론(Reasoning)**이 핵심이다.
모델은 답을 내기 전에 구조화된 내부 추론을 수행한다:

- 작업 분해
- 옵션 평가
- 멀티스텝 편집 계획

`reasoning_effort` 파라미터(`high`, `xhigh`)로 추론 깊이를
조절할 수 있다. 높을수록 지연은 증가하지만 결과가 좋아진다.

현재 OpenAI 플래그십 모델:

- **GPT-5.3-Codex**: 복잡하고 장기 실행되는 에이전틱 코딩
- **GPT-5.3-Codex-Spark**: 실시간 상호작용에 최적화된 소형 모델

**요점**: 모델은 지능이다. 그러나 지능만으로는 에이전트가
되지 않는다.

---

## 하니스(Harness): 모델을 에이전트로 변환하는 것

모델은 코드 생성과 diff 추론은 가능하지만, 혼자서 실제
저장소 내부에서 동작할 수는 없다. 파일 시스템 검사, 테스트
실행, 빌드 실행 같은 작업은 하니스가 담당한다.

하니스가 제공하는 것:

- 파일과 저장소에 대한 제어된 접근
- 명령어를 안전하게 실행하는 능력
- 대규모 작업에서도 컨텍스트를 유지하는 구조

> 하니스 없이 → **제안(Suggestions)**
> 하니스와 함께 → **실행(Execution)**

하니스는 오픈소스다: <https://github.com/openai/codex/>

장기 실행 작업에서는 **컴팩션(Compaction)**을 사용한다.
계속 늘어나는 대화 기록을 요약으로 압축해 연속성을 유지한다.

---

## 모델과 하니스의 공동 설계

모델과 하니스는 별도로 만든 후 조합된 것이 아니다.
**Codex 모델은 하니스가 있는 환경에서 함께 훈련된다.**

도구 사용, 실행 루프, 컴팩션, 반복 검증은 추가된 동작이
아니라, 모델이 학습하는 방식 자체에 내재되어 있다.

비유: 프로 선수와 라켓. 특정 장비로 수년간 훈련한 선수에게
경기 전날 장비를 바꾸면 같은 성능을 기대할 수 없다.

---

## 서피스(Surfaces): 에이전트를 사용하는 방법

동일한 에이전트를 다양한 서피스를 통해 사용할 수 있다.

- **Codex 앱**: 병렬 스레드 오케스트레이션, 장기 실행 작업
  감독, 자동화 및 Git 기능 내장
- **CLI**: 터미널 우선 워크플로우, 스크립트/CI 파이프라인
  통합, TypeScript SDK 제공
- **VSCode 확장**: 빠른 인컨텍스트 편집, diff 리뷰 중심
- **웹 인터페이스**: 경량 비동기 작업 시작 및 감독
- **GitHub, Slack, Linear**: 협업 워크플로우 내 통합

대부분의 경험은 **Codex App Server**(오픈소스)로 구동된다.

---

## 핵심 인사이트

### 1. 하니스가 에이전트의 본질이다

모델은 지능이고, 하니스는 그 지능을 현실 세계에서 작동하게
만드는 메커니즘이다. "AI가 코드를 짠다"는 말의 실체는
모델 + 하니스의 조합이다.

**모델만 바꾸거나 하니스만 바꾸면 에이전트의 동작이
달라진다.** 둘은 분리할 수 없는 한 쌍이다.

### 2. 레이어 분리로 변화를 읽어라

새 기능이 출시될 때, 모델이 바뀐 건지, 하니스가 바뀐 건지,
서피스가 바뀐 건지를 파악하면 의미를 정확히 이해할 수 있다.
업데이트 노이즈를 레이어별로 필터링하라.

### 3. 컨텍스트 관리가 에이전트 성능의 핵심이다

장기 실행 에이전트에서 컨텍스트 폭발은 치명적이다.
컴팩션(압축 요약)으로 이를 해결하는 전략을 반드시 갖춰야
한다. 에이전트 시스템을 설계할 때 컨텍스트 관리는 1급
문제다.

### 4. 공동 설계(Co-design)는 선택이 아닌 필수다

에이전트 시스템에서 모델과 실행 환경을 분리해서 생각하면
안 된다. 최고 성능은 모델과 하니스가 함께 설계되고 훈련될
때 나온다. LLM 에이전트를 만드는 모든 팀이 고려해야 할
아키텍처 원칙이다.

### 5. 서피스는 워크플로우 매칭이다

동일한 에이전트라도 사용 맥락에 따라 다른 서피스가 적합하다.
병렬 감독이 필요하면 앱, 터미널 친화적이면 CLI, 빠른
인라인 편집이면 IDE 확장을 선택하라. 서피스는 취향이 아닌
워크플로우의 문제다.

### 6. 이름의 연속성과 시스템의 단절

원래 Codex는 GitHub Copilot 초기를 지원한 모델 이름이었다.
오늘날의 Codex는 다른 아키텍처, 다른 하니스, 다른 에이전트
설계다. **이름이 같아도 시스템은 완전히 다를 수 있다.**
제품 이름에 속지 말고 실제 동작 방식을 들여다봐야 한다.

### 7. 이론보다 실습이 먼저다

에이전틱 코딩을 시작하려면 아키텍처를 먼저 이해하려 하지
말고, 실제 작업에 적용해 보는 것이 먼저다. Codex 앱이 가장
쉬운 진입점이다. 이해는 사용하면서 따라온다.

---

## 관련 링크

- [Codex 공식 문서](https://developers.openai.com/codex)
- [Codex 오픈소스 하니스](https://github.com/openai/codex/)
- [Unlocking the Codex Harness](https://openai.com/index/unlocking-the-codex-harness/)
