# Chapter 3 - Model-Driven Design

## 인용

> 분석 모델은 비즈니스 도메인 부석의 결과물일 뿐이고, 소프트웨어 구현은
> 염두에 두지 않는다. 이런 모델은 도메인을 이해하기 위해서만 사용한다.
> (p.47)

---

> 그 결과, 분석 모델은 코딩이 시작되자마자 곧바로 폐기되고 만다.
> (p.47)

---

> 만약 개발자들이 분석가들의 회의에 함께 참여하고, 코드를 설계하기 전에
> 도메인과 모델을 명확하고도 완전하게 이해한다면 훨씬 더 생산적일 것이다.
> (p.49)

---

> 모델이란 소프트웨어 그 자체와 설계 고려 사항에 초점을 맞추어 만들어져야 하며,
> 개발자들은 모델링 프로세스가 진행되는 동안 함께 참여해야 한다.
> (p.49)

---

> 코드는 모델을 표현할 것이고, 코드의 변경이 곧 모델의 변경으로 이어질 것이다.
> 이것은 프로젝트의 관련 활동들이 모두 연쇄적으로 영향을 받게 될 것임을
> 의미한다.
> (p.51)

---

> **하나의 레이어에 도메인과 관련된 모든 코드를 집중**시켜서,
> 사용자 인터페이스, 애플리케이션, 인프라스트럭처 코드로부터 **독립적**으로
> 만들어야 한다.
> (p.55)

이 부분이 핵심적.

---

> **하나의 레이어에 도메인과 관련된 모든 코드를 집중**시켜서,
> 사용자 인터페이스, 애플리케이션, 인프라스트럭처 코드로부터 **독립적**으로
> 만들어야 한다.
> (p.55)

---

> **동일하다**는 것이 어떤 의미인지가 반드시 모델에서 정의되어야 한다.
> (p.61)

---

> 서비스가 **도메인 레이어**나 **인프라스트럭처 레이어** 중 어느 쪽에
> 속하는지는 혼동하기 쉽다.
> (p.68)

---

> **애플리케이션 레이어**는 사용자 인터페이스와 도메인 및 인프라스트럭처
> 사이의 얇은 레이어라고 할 수 있다.
> (p.69)

---

> 시스템을 잘 설명할 수 있고, **응집도** 높은 개념의 집합으로 구성되도록
> **모듈**을 선정하라.
> 이렇게 하면 대개 모듈 간의 **결합도**를 낮춰 얻을 수 있다.
> (p.72)

---

> **root**는 엔티티이고 **외부에서 접근할 수 있는 창구**다.
> root는 집합된 다른 객체들에 대한 참조를 담고 있으며, 다른 객체들은 서로
> 관계를 맺고 있다.
> 그러나 객체의 외부에서는 root 객체를 통해서만 참조할 수 있다.
> (p.77)

---

> 엔티리를 하나 선정하여 각 집합의 root로 삼고, 경계 내부의 객체들에는
> root를 통해서만 접근하도록 제어하라.
> 외부 객체들은 root에 대해서만 참조할 수 있어야 한다.
> (p.79)

---

> 이러한 방식의 제어권 할당은 집합 내부 객체들 및 전체 집합 자체가 어떠한
> 상태 변화에도 전체적으로 **불변식**을 보장할 수 있는 실용적 방안이다.
> (p.79)

## 번역 이슈

> **Customer 객체**가 다른 객체를 생성하고자 할 때…
> (p.80)

원서에는 아주 명확히 “client object”라고 나와 있음.

Client와 Customer를 임의로 바꿔서 쓴 건데,
원론적으로 보나 문맥으로 보나 Client는 객체를 쓰는 쪽을 의미함.

번역서의 경우 해당 페이지 상단에 Customer가 나오는데,
만약 독자가 이것과 연결해서 읽으면 최악의 결과가 나오게 된다.

이후로도 계속 Customer 객체라는 표현을 쓰는데,
다음과 같은 문장은 코믹하기까지 하다.

> 이것은 이 객체를 생성하도록 요청한 **Customer 객체**가 생성될 객체에 대해
> 특별한 지식을 지녀야만 될 것이라는 의미다.
> (p.81)

해당 문장은 원서에는 다음과 같이 혼동할 수 없게 씌여있다.

> This means that each **client of the object** will hold specific knowledge
> about the object built.

Customer가 아니라 “고객”이라고 쓰면 더 웃기는 표현이 나온다.

> 만약 **고객**이 애플리케이션 레이어에 속한다면 도메인 레이어의 일부 정보를
> 레이어 밖으로 내보내는 결과를 가져올 것이고, 전체 설계는 뒤죽박죽이 된다.
> (p.81)

뒤죽박죽인 건 이 문장이다. 원서의 표현은 다음과 같다.

> If the **client** belongs to the application layer, a part of the domain
> layer has been moved outside, messing up the entire design.

애플리케이션에 있는 도메인 객체의 클라이언트라면 일반적으로는 애플리케이션
서비스를 의미한다.
