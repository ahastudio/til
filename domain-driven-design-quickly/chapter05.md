# Chapter 5 - Preserving Model Integrity

## 인용

> 한 프로젝트에 여러 팀이 참여할 경우 각 팀이 모델의 특정 부분을 할당 받아
> 작업하는 형식으로 코드 개발을 병렬적으로 할 수 있다.
> 이 특정 부분들은 완전히 독립적이지는 않고, 어느 정도는 상호 연관된다.
> (p.107)

---

> 어느 누구도 전체 모델을 완벽하게 이해하고 있지 못하기 때문에, 이런 일은
> 쉽게 발생할 수 있다.
> 누구나 그 자신만의 영역을 가지고 있으며 다른 분야에 대해서는 필요한 만큼
> 자세히 알고 있지 못한다.
> (p.108)

---

> 기업 규모의 대형 프로젝트 전체를 커버하는 통합된 모델을 유지하기 위해
> 고군분투하면서 모델의 무결성을 지키려는 작업은 제대로 수행되기에는 너무
> 어려운 일이다.
> (p.109)

---

> 새로운 접근법이 있는데,
> 결국에는 쪼개질 하나의 큰 모델을 유지하려고 노력하는 대신에,
> 의도적으로 이것을 여러 개의 모델로 분할하는 것이다.
> (p.109)

---

> ‘하나의 모델은 하나의 팀에 할당하기에 적합할 만큼 작아야 한다.’
> (p.111)

---

> 모델의 컨텍스트란 모델 안에서 사용된 용어들이 특정한 의미를 가지는 것을
> 보장할 수 있도록 적용되는 조건들의 집합이라고 할 수 있다.
> (p.111)

---

> 모델의 범위를 정의하는 작업의 기본 개념은,
> 모델의 범위를 정하고 컨텍스트 간의 경계를 설정한 다음
> 모델이 통합된 상태를 최대한 유지하도록 하는 것이다.
> (p.111)

---

> 모델이 기업 프로젝트 전체 영역에 펼쳐져 있다면,
> 모델의 순수성을 유지하기가 매우 어렵다.
> 그러나 특정 영역에 국한되어 있다면 훨씬 쉽다.
> (p.111)

---

> 여러 모델을 가지려면 그 대가를 치어랴 한다.
> 우리는 서로 다른 모델 간의 경계와 관계를 정의할 필요가 있다.
> 그러려면 부가적인 작업을 하고 설계에 노력을 기울여야 하며,
> 서로 다른 모델끼리 얼마간 번역할 필요도 있다.
> (p.112)

---

> 모델은 초기부터 충분하게 정의될 수 없다.
> 모델은 생성되고 나면 개발 프로세스 동안 도메인에 대한 새로운 이해를 바탕으로
> 끊임없이 피드백을 받는다.
> (p.115)

---

> 우리는 모든 새로운 구성 요소가 기존 모델에 조화롭게 추가 적용되고,
> 코드로 올바르게 구현되도록 보장할 수 있는 통합된 프로세스가 필요하다.
> (p.116)

---

> 개별적으로 통합된 여러 개의 분리된 모델을 가지고 있는 것으로는 충분하지 않다.
> 각 모델의 기능은 전체 시스템의 일부일 뿐이기 때문에 반드시 통합되어야 한다.
> (p.118)

---

> 다시 말해 이처럼 **명시적으로 공유된 부분**은 특별한 상태를 지니며,
> 다른 팀과 협의하지 않고 변경해서는 안 되는 공유된 요소가 되는 것이다.
> (p.120)

---

> 커널에 대한 어떠한 변경이든지 상대 팀과 의사소통해야 하며 새로운 기능을
> 인식할 수 있도록 정보를 알려야 햔다.
> (p.121)

---

> 공급자 팀은 전적으로 자신들의 설계를 바탕에 두고 일할 수 있을 것이다.
> (p.125)

---

> 고객-공급자 관계는 양쪽 팀이 관계에 관심 있을 때 성공할 수 있다.
> 고객은 공급자에 대해 매우 의존적인 반면 공급자는 그렇지 않다.
> (p.125)

---

> 고객 팀에게는 선택의 여지가 별로 없다.
> 가장 확실한 것은 공급자로부터 분리된 그들만의 소유로,
> 모든 필요한 것을 만드는 방법이다.
> (p.127)

---

> 변질 방지 레이어는 외부 모델에게 클라이언트 언어가 아닌 외부 언어로 말한다.
> 이 레이어는 두 개의 서로 다른 도메인과 언어 간에 양방향 번역자의 역할을 한다.
> 가장 큰 장점은 클라이언트 모델이 외부로부터 영향 받는 오염 없이
> 순수하고 일관된 상태로 남는다는 것이다.
> (p.131)

---

> 통합할 때 생길 이익을 면밀히 검토해야 하고,
> 진정 가치가 있을 때에만 그렇게 해야 한다.
> 만약 **통합의 가치**가 **파생되는 문제점**보다 작다고 결론짓는다면
> 우리는 분할 방식으로 가야 한다.
> (p.133)

---

> 분할 방식으로 진행하기에 앞서 통합된 시스템으로 되돌아가지 않을 것임을
> 확실히 할 필요가 있다.
> (p.134)

---

> 시스템의 핵심 도메인은 우리가 시스템을 어떻게 보느냐에 달려 있다.
> (p.138)

---

> 가장 가치 있고 특화된 개념을 강조하고, 핵심을 작게 유지하라.
> (p.139)

---

> 당신의 최고의 재능을 핵심 도메인에 쏟고,
> 핵심 도메인을 기준으로 사람을 채용하라.
> (p.139)

---

> 그럼에도 불구하고, 도메인의 비즈니스 로직은 도메인의 심장이다.
> 핵심부에 대한 설계나 구현의 실수는 프로젝트를 전면적 실패로 이끈다.
> 만약 핵심 비즈니스 로직이 제 역할을 하지 못한다면,
> 멋진 기술적 부가 기능은 모두 무용지물이 된다.
> (p.139)

---

> 핵심 도메인은 단번에 만들어지지 않는다.
> 핵심이 한층 명확하게 통합되기 위해서 정제와 지속적인 리팩터링이 필요하다.
> 우리는 핵심을 설계의 중심부로 규정하고 그 경계를 명확히 할 필요가 있다.
> (p.140)

## 번역 이슈

> 우리의 **고객** 시스템이 외부 시스템과 상호작용하는 데는
> 여러 가지 방법이 있다.
> (p.145)

바로 앞에서 고객과 공급자를 언급하는데, 둘은 Customer와 Supplier다.
그리고 Anticorruption Layer에서 이 부분의 원문은 다음과 같다.

> There are different ways for our **client** system to interact
> with an external one.

Customer와 Client는 엄연히 다르고, 여기서 Client는 완벽히 기술적인 용어로
쓰이고 있다.

게다가 바로 아래에는 이렇게 번역을 했다.

> **클라이언트**는 외부 시스템을 사용하기 위해서 해당 인터페이스에
> 밀착되어야 한다.

당연히 이쪽이 올바른 번역이다.

---

1️⃣

> 외부 서비시스템을 **서비스**로 감쌀 수 있다면,
> (p.135)

2️⃣

> 따라서 일관성 있는 **서비스의 세트**를 만들려고 하면
> (p.135)

3️⃣

> 자신의 시스템에 접근할 수 있는 프로토콜을 **서비스의 집합**으로 정의하라.
> (p.136)

세 부분이 각각 다르게 번역됐지만 원서에서는 “**set of Services**”란 표현
하나만 사용하고 있다.
단순하고 일관된 번역을 유지하는 게 필요하다.
