# AI 시대에 TDD가 더 강력해진 이유

Marco Franzon (@mfranz_on) (2026-02-26):
<https://twitter.com/mfranz_on/status/2026762513094758497>

"Test-Driven Development Will Make You a 100x Engineer"

## 요약

병목은 사라지지 않았다. 이동했을 뿐이다.

AI가 코드를 즉시 생성하는 시대가 왔다.
그런데 많은 개발자들이 오히려 더 느려졌다고 느낀다.
디버깅, 리팩터링, 이해하지 못한 코드와의 씨름.

병목이 "코드 작성 속도"에서
"코드 신뢰성 검증 속도"로 이동했기 때문이다.

이 새 병목을 정확히 해소하는 실천법이 TDD다.

---

## 분석

### AI 코드 생성의 환상

AI가 만든 코드는 완성된 것처럼 보인다.
컴파일되고, 주석도 달려 있고, 깔끔하다.
이 외관이 함정이다.

AI는 추론 엔진이 아니다.
패턴 기반으로 그럴듯한 출력을 생성하는 확률 모델이다.
"올바르게 보이는 것"과 "올바른 것"은 전혀 다른 문제다.

피보나치 함수 예시:

- 제약 없이 요청하면 → 재귀(recursive) 구현
- 결과: 우아해 보이지만 큰 입력에서 스택 오버플로우
- 음수 입력 처리 없음, 성능 보장 없음

이것은 AI가 무능해서가 아니다.
학습 데이터에서 재귀 구현이 가장 많이 등장하기 때문이다.
AI는 주어진 제약 없이는 "빈도가 높은 패턴"을 고른다.

정확성은 외관으로 추론할 수 없다. 증명해야 한다.

### Red-Green-Refactor의 역할 재분배

TDD의 루프: 실패 테스트 작성 → 통과 → 리팩터링.

AI 시대에 이 루프의 주도권이 달라진다.

| 단계      | 주도  | 역할                                  |
|-----------|-------|---------------------------------------|
| Red       | 인간  | 의도와 명세를 테스트로 결정화         |
| Green     | AI    | 테스트를 제약 삼아 정확한 구현 생성   |
| Refactor  | 협력  | AI가 구조 개선, 테스트가 회귀 방지    |

**Red 단계: 인간의 가장 중요한 기여**

테스트를 먼저 쓰는 행위는
"이것이 올바른 동작이다"를 명시적으로 선언하는 것이다.

이 선언에는 다음이 포함된다:

- 정상 입력의 기대 출력
- 경계 조건 (0, 음수, 빈 문자열, 최대값)
- 예외 상황에서의 동작
- 성능 요구사항이 있다면 그것도

이것을 작성하기 위해서는 도메인을 이해하고,
사용자의 의도를 파악하고,
"빠뜨린 게 무엇인가"를 미리 물어야 한다.
이것은 AI가 대신할 수 없는 인간의 작업이다.

**Green 단계: AI의 최적 활용**

테스트가 명확한 제약으로 주어지면
AI는 그 제약 안에서 정확한 구현을 만들어낸다.
에러 메시지 자체가 다음 프롬프트가 된다.
실패 이유가 명확하면 이터레이션이 빨라진다.

피보나치 예시에서:
- 큰 값에 대한 테스트가 있으면 → 반복(iterative) 구현
- 음수 입력 오류 테스트가 있으면 → 검증 로직 포함
- 테스트가 정확할수록 첫 구현이 올바를 확률이 높다

차이는 모델의 지능이 아니라 명세의 명확성이다.

**Refactor 단계: 테스트가 안전망**

모든 테스트가 통과된 상태에서
AI에게 "구조를 개선해달라"고 요청한다.
테스트 스위트가 회귀(regression)를 즉시 포착한다.
안전하게 위임할 수 있다.

### 테스트는 프롬프트보다 정확한 명세다

프롬프트는 모호하다. 자연어는 해석에 의존한다.

"로그인 실패 시 적절히 처리해줘"는
수십 가지로 해석될 수 있다.

```
expect(login('wrong-password')).toThrow(AuthError)
expect(login('wrong-password')).toThrow('Invalid credentials')
expect(loginAttempts.count).toBe(1)
```

이것은 해석의 여지가 없다.
동작을 기술하는 것이 아니라 시연한다.

테스트가 잘 갖춰진 코드베이스는
AI에게 최고의 컨텍스트다.
무엇이 올바른지를 기계가 읽을 수 있는 형태로
이미 정의해 둔 것이기 때문이다.

### 피드백 루프와 복잡도 폭증 방지

AI와 함께 작업할 때 가장 위험한 패턴:

1. 프롬프트 → 수백 줄 생성
2. 확인 없이 다음 프롬프트
3. 반복
4. 검증되지 않은 코드 수천 줄

이 시점에서 버그를 잡는 것은 재앙이다.
어디서 잘못됐는지 모른다. 무엇이 의존하는지 모른다.

TDD는 이 폭증을 구조적으로 막는다:

- 테스트 하나 → 구현 → 통과 → 다음
- AI가 빠르게 생성해도 검증이 작은 단위로 유지됨
- 에러는 발생 직후, 원인 가까이에서 포착됨

역설적으로: 테스트를 먼저 쓰면 전체 시간이 준다.
초기 투자보다 디버깅과 재작업 절감이 크다.

---

## 인사이트

### 검증이 새로운 병목이다 — Karpathy의 진단과 연결

Karpathy는 AI가 "에디터에 코드를 타이핑하는
70년 패러다임을 끝냈다"고 선언했다.
([AI가 프로그래밍을 바꾼 방식](./karpathy-ai-programming-impact.md))

동시에 그가 진단한 새로운 병목:

> "검증(review)이 새로운 병목이 된다.
> 생성 속도는 이미 인간 검증 속도를 앞질렀다."

TDD는 이 새 병목에 정확히 대응한다.
검증을 자동화하고, 점진적으로 유지하고,
에러를 발생 즉시 포착한다.
에이전트가 빠를수록 TDD의 가치가 올라간다.

### Augmented Coding과 Vibe Coding의 분기점

Kent Beck은 AI 코딩 방식을 두 가지로 대비시킨다:

**Vibe Coding**: 코드를 신경 쓰지 않는다.
프롬프트를 던지고 결과를 받는다.
빠르고 쉽지만, 코드베이스는 검증되지 않은
패턴의 누적이 된다.

**Augmented Coding**: 코드 품질, 테스트 커버리지,
복잡성 관리에 집중한다.
AI를 도구로 쓰되, 인간이 기준을 유지한다.

> "Augmented coding means never having to say no
> to an idea."

TDD가 이 분기를 만드는 실천 방법이다.
테스트가 있으면 Augmented Coding이다.
테스트 없이 생성만 하면 Vibe Coding이다.

Kent Beck의 실험: AI에게 이렇게 지시했다.

> "Act as a senior software engineer who follows
> Kent Beck's Test-Driven Development (TDD) and
> Tidy First principles."

결과가 즉시 달라졌다.
TDD 원칙을 AI에게 지시할 수 있다면,
그 원칙을 인간이 먼저 이해하고 있어야 한다.

### 결승선 게임 vs 복리 게임

Kent Beck의 "Earn and Learn"에서:
([Earn and Learn](./earn-and-learn.md))

**결승선 게임**: 목표 X에 도달하면 끝.
미래가 없으니 미래를 고려할 필요가 없다.
AI는 이 게임을 역사상 가장 빠르고 싸게 해준다.

**복리 게임**: 지금 만든 것이 다음 것의 밑천이 된다.
코드, 테스트, 팀의 이해, 도메인 지식 전부.
이 게임에서 테스트는 "futures(미래 옵션)"다.

TDD의 진짜 가치는 복리 게임에 있다.

AI가 생성한 테스트 없는 코드는
결승선 게임의 산출물이다.
빠르게 기능을 만들었지만 futures가 없다.
다음 변경이 어렵고, 복잡성이 쌓이면 게임 오버.

테스트가 있는 코드베이스는 futures를 가진다.
다음 변경을 받아들일 준비가 되어 있다.
AI가 더 잘 도와줄 수 있는 상태가 유지된다.

> AI가 결승선 게임을 무료로 만들어줄수록,
> 복리 게임을 할 줄 아는 사람의 가치가
> 기하급수적으로 올라간다.

### 명세 능력이 새로운 기술 스택이다

Karpathy의 핵심 관찰:

> "잘 명세되고 검증 가능한 조건을 충족하는 작업에서
> 에이전트가 특히 잘 작동한다."

TDD는 명세 능력을 훈련하는 가장 정제된 방법이다.

테스트를 잘 쓰는 능력은 다음의 결합이다:

- 도메인 이해: 무엇이 올바른가를 안다
- 경계 식별: 어디서 무너지는가를 미리 본다
- 추상화: 구현이 아닌 동작으로 사고한다
- 모호성 해소: "적절히"를 "구체적으로" 바꾼다

이것은 프로그래밍 언어 숙련도와 다른 기술이다.
AI가 구현을 대신할수록 이 기술의 가격이 오른다.
명세 능력이 있는 사람이 에이전트를 더 잘 쓴다.

### Canon TDD의 "실수 목록"이 더 중요해졌다

[Canon TDD](./test-driven-development.md)에서
Kent Beck은 각 단계의 흔한 실수를 나열했다.

AI와 함께하면 이 실수들을 더 빠르게 저지른다:

**3단계 실수: 이중 검증 무력화**

> "실제 계산된 값을 복사해서 기대값에 붙여넣는 것"

AI가 생성한 코드의 출력을 그대로 기대값으로 쓰면
이 실수를 자동으로 저지른다.
AI가 잘못 계산해도 테스트가 통과한다.

**3단계 실수: 통과와 리팩터링 혼합**

AI는 "작동하게" 만들면서 동시에 "올바르게" 만들려 한다.
이 두 단계를 분리해서 요청해야 한다.

**4단계 실수: 과도한 리팩터링**

> "이번 세션에 필요한 것 이상으로 리팩터링하는 것"

AI에게 Refactor를 요청하면 과도하게 추상화한다.
Karpathy가 관찰한 "코드 과잉 복잡화"와 같다.
테스트가 이 한계를 강제한다.

### Atrophy — 퇴화하지 않는 근육

Karpathy의 경고:

> "코드 작성 능력이 서서히 퇴화하기 시작했다."

AI를 많이 쓸수록 직접 코딩 능력이 줄어든다.
이것은 피할 수 없는 트레이드오프다.

그러나 테스트 작성 능력은 다르다.

테스트를 쓰는 것은 구현을 쓰는 것이 아니다.
도메인을 이해하고, 동작을 명시하고,
경계를 식별하는 것이다.
이것은 AI를 많이 쓸수록 오히려 더 강화된다.

AI가 구현한 것을 테스트로 검증하는 반복이
명세 능력을 훈련한다.
퇴화하지 않는 근육을 키우는 방법이 TDD다.

---

## 결론

AI는 구현을 담당한다.
인간은 의도를 정의하고 결과를 검증한다.
테스트는 이 분업이 무너지지 않게 하는 계약이다.

TDD는 느리고 번거로운 옛 방식이 아니다.
AI와 함께 일하는 구조에서
가장 강력한 안전망이자 소통 도구다.

테스트를 먼저 쓰는 사람이
AI를 올바르게 쓰는 사람이다.

---

## 관련 문서

- [테스트 주도 개발](./test-driven-development.md)
- [AI가 프로그래밍을 바꾼 방식](../ai/karpathy-ai-programming-impact.md)
- [Karpathy's Claude Coding Notes](../ai/karpathy-claude-coding-notes.md)
- [Vibe Coding](../ai/vibe-coding.md)
- [Spec-Driven Development](../ai/spec-driven-development.md)
- [Earn and Learn](./earn-and-learn.md)
