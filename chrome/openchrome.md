# OpenChrome

오픈소스 브라우저 자동화 MCP 서버.
AI 에이전트가 실제 Chrome 인스턴스를 제어할 수 있게 한다.

<https://github.com/shaun0927/openchrome>

## 핵심 가치

**"Smart. Fast. Parallel."**

기존 브라우저 자동화의 세 가지 병목을 정면으로 해결한다:

| 문제                   | 기존 방식           | OpenChrome          |
| ---------------------- | ------------------- | ------------------- |
| 속도                   | 5개 사이트 ~250초   | ~3초                |
| 메모리                 | ~2.5GB              | ~300MB              |
| LLM 호출              | ~100회              | ~20회               |

데모 영상이 이 차이를 극적으로 보여준다. 좌측 Playwright MCP는
AWS Billing, Stripe, Vercel, GitHub, Slack 5개 사이트를 순차
처리하면서 사이트마다 30-60초씩 로그인한다. 총 250초, 2.5GB.
우측 OpenChrome은 5개 사이트를 동시에 시작하고 3.1초 만에
전부 완료한다. 로그인 제로, 대기 제로, 전부 병렬.

단일 Chrome 프로세스에서 20개 이상의 병렬 세션을 실행하면서
메모리를 300MB 수준으로 유지한다. 비결은 사이트별로 브라우저
인스턴스를 띄우는 대신, 하나의 Chrome에서 경량 워커 컨텍스트
5개를 병렬로 돌리는 것이다. 실제 Chrome 프로필의 인증 상태를
그대로 사용하므로 로그인 자체가 필요 없다.

## 아키텍처

```
┌─────────────────────────────────────────────┐
│                MCP Server                   │
│           (JSON-RPC 2.0 / stdio)            │
├─────────────────────────────────────────────┤
│  Session Manager                            │
│  ├── Worker (격리된 브라우저 컨텍스트)       │
│  │   └── Target (페이지/탭, 워커당 최대 5)  │
│  ├── CDP Connection Pool                    │
│  └── Chrome Pool (origin-aware, 최대 5)     │
├─────────────────────────────────────────────┤
│  47개 도구  │  힌트 엔진  │  오케스트레이션  │
├─────────────────────────────────────────────┤
│  Browser Router (회로 차단기 패턴)          │
│  ├── Chrome (시각 도구, PDF 등)             │
│  └── Lightpanda (경량 브라우저 대안)        │
├─────────────────────────────────────────────┤
│  Chrome DevTools Protocol (CDP)             │
│  ├── client.ts (하트비트, 프로미스 병합)    │
│  ├── connection-pool.ts (페이지 풀링)       │
│  └── screenshot-scheduler.ts (동시 5)       │
├─────────────────────────────────────────────┤
│  Chrome (Puppeteer Core)                    │
└─────────────────────────────────────────────┘
```

### 세션 계층 구조

```
SessionManager
└── Session (기본 TTL: 30분)
    ├── Worker (기본 + 커스텀 워커)
    │   └── Target (페이지/탭)
    └── Browser Context (쿠키/스토리지 격리)
```

세션 매니저의 설계가 인상적이다. 메모리 압박 시 가용 RAM이
500MB 이하로 떨어지면 공격적으로 세션을 정리한다. 죽은 타겟
ID를 URL 매칭으로 라이브 타겟에 재매핑하는 복구 메커니즘도
갖추고 있다. OAuth 리다이렉트 같은 크로스오리진 네비게이션
에서도 세션이 유지된다.

## 핵심 모듈 분석

### 1. 힌트 엔진 (src/hints/)

LLM 호출을 80% 줄이는 핵심 차별화 요소다.

6계층 규칙 시스템:

| 우선순위 | 규칙                 | 역할                   |
| -------- | -------------------- | ---------------------- |
| 90       | 설정 힌트            | 초기 설정 가이드       |
| 100-108  | 오류 복구            | 실패 시 자동 복구      |
| 190-192  | 페이지네이션 감지    | 다음 페이지 자동 탐지  |
| 200-203  | 복합 제안            | 다단계 작업 축약       |
| 245-252  | 반복 감지            | 루프 패턴 식별         |
| 300-304  | 시퀀스 감지          | 작업 흐름 예측         |
| 350      | 학습된 규칙          | 패턴 학습 결과 적용    |
| 400-403  | 성공 힌트            | 완료 시 다음 단계 제안 |

**심각도 에스컬레이션**: 같은 규칙이 반복 발화되면 심각도가
자동 상승한다.

- 1-2회: info (원본 텍스트)
- 3-4회: warning (경고 접두사)
- 5회 이상: critical (액션 히스토리 포함)

10회 연속 미스 시 발화 카운트가 0으로 리셋되어 오래된
에스컬레이션을 자연 감쇠시킨다.

**패턴 학습기**(pattern-learner.ts)가 실행 중 패턴을 학습해
학습된 규칙으로 피드백하는 적응형 구조다. JSONL 기반 비동기
버퍼 로깅(200ms 플러시)으로 메인 스레드를 차단하지 않는다.

### 2. DOM 직렬화 (src/dom/)

토큰 사용량을 5-10배 줄이는 또 다른 핵심이다.

CDP DOM 트리를 컴팩트 텍스트로 변환한다. script, style 등
불필요한 요소를 완전히 건너뛰고, id, name, aria-label 등
관련 속성만 보존한다.

출력 형식: `[backendNodeId]<tagName attrs/>textContent ★`

인터랙티브 요소(input, button, select 또는 ARIA 역할)에
★ 마커를 붙여 AI가 즉시 식별할 수 있게 한다.
interactiveOnly, pierceIframes, maxDepth, maxOutputChars
옵션으로 출력을 세밀하게 제어할 수 있다.

### 3. 오케스트레이션 엔진 (src/orchestration/)

병렬 워크플로우의 뇌다.

- **plan-executor.ts**: 플랜 실행
- **plan-registry.ts**: 플랜 등록/관리
- **state-manager.ts**: 상태 추적
- **workflow-engine.ts**: 핵심 엔진

**하이브리드 상태 관리**: 인메모리 상태를 정합성의 단일
진실 원천(source of truth)으로 사용하고, 파일 기반 영속성은
디버깅용 보조 수단으로만 활용한다. 프로미스 기반 뮤텍스
(`completionLock`)로 동시 완료 시 lost update를 방지한다.

**회로 차단기**: 워커별 절대 타임아웃(기본 60초), 전역
워크플로우 타임아웃(기본 300초), 데이터 해시 기반 정체 감지
(동일 데이터 5회 연속 시 강제 완료)를 갖추고 있다.

**Ralph Loop 알고리즘**: 워커 프롬프트에
assess -> decide -> execute -> update 루프를 삽입해
에이전트의 자율 실행을 구조화한다.

### 4. CDP 커넥션 풀 (src/cdp/)

페이지 획득 시간을 100ms 이하로 끌어내리는 인프라다.

사전 할당된 Puppeteer 페이지를 관리한다. 반환된 페이지는
about:blank로 이동 후 쿠키/스토리지를 CDP로 클리어한 뒤
풀에 복귀한다. 30초 간격 유지보수 타이머로 유휴 페이지를
정리하면서 최소 풀 사이즈를 보장한다.

"Fire-and-forget" 릴리즈 패턴으로 호출자를 차단하지 않는다.

### 5. 하이브리드 브라우저 라우팅 (src/router/)

Chrome과 Lightpanda 두 브라우저 백엔드 사이를 라우팅한다.

**회로 차단기 패턴**: Lightpanda 실패 시 Chrome으로 자동
에스컬레이션하고 쿠키를 동기화한다. 시각 도구(computer,
page_pdf)는 Chrome 전용으로 강제하고, 나머지 48개 이상의
도구는 Lightpanda를 선호한다.

**양방향 쿠키 동기화**: 5초 간격 주기적 동기화로 두 백엔드
간 세션 일관성을 유지한다. Lightpanda에서 Chrome으로의
병합 전략이 별도로 구현되어 있다.

경량 브라우저를 메인으로 쓰되 필요할 때만 Chrome으로
올리는 이 전략은 리소스 효율과 기능 완전성을 동시에
잡는다.

### 6. 플랜 캐싱 시스템 (src/orchestration/)

`PlanRegistry`가 실행된 플랜을 `~/.openchrome/plans/`에
영속화한다. URL 패턴, 키워드, 신뢰도 기반으로 태스크를
매칭하고, 성공/실패 통계를 롤링으로 추적한다. 최소 신뢰도
0.3 이상의 플랜만 재사용한다.

`PlanExecutor`는 사전 컴파일된 플랜을 도구 핸들러 직접
호출로 실행한다. 템플릿 변수 치환, 타임아웃 보호, 에러
핸들러 체인, 성공 기준 검증까지 갖추고 있다.

반복적인 자동화 작업에서 "한 번 학습, 계속 재사용"이
가능해진다.

### 7. 도메인 메모리 (src/memory/)

`~/.openchrome/memory/domain-knowledge.json`에 도메인별
지식을 영속 저장한다. 신뢰도 점수 체계(시작 0.5, 성공
+0.1, 실패 -0.2)로 지식 품질을 관리한다. 신뢰도 0.2
미만이거나 30일 이상 미사용 항목은 자동 정리되며, 최대
200개 엔트리로 제한한다.

워커 프롬프트 생성 시 해당 도메인의 학습된 지식이 자동
주입된다.

### 8. 보안 계층 (src/security/)

- **domain-guard.ts**: 중앙화된 도메인 차단 목록. 글로브
  패턴 매칭. DNS 최대 253자 검증. about:, chrome:, data:,
  file: 등 특수 URL은 허용.
  `assertDomainAllowed()`가 모든 getPage() 호출을 보호한다.
- **audit-logger.ts**: JSONL 감사 로그를 `~/.openchrome/
  audit.log`에 기록. password, token, credential 등
  민감 데이터를 자동 수정(redaction)한다. 논블로킹 쓰기.

### 9. 설정 복구 (src/config/)

`.claude.json` 설정 파일의 자동 백업/복구 시스템이다.
다중 전략 복구(유효 JSON 추출, 백업 복원, 빈 설정 폴백)를
시도한다. 파일 감시자(file watcher)가 손상을 감지하면 자동
복구하며, 최근 10개 백업을 유지한다.

`session-isolator.ts`는 Claude 세션별 별도 디렉토리를
생성해 설정 레이스 컨디션을 방지한다. 24시간 이상 된
오래된 세션은 자동 정리한다.

## 47개 도구

7개 카테고리로 분류된다:

| 카테고리         | 도구 예시                            |
| ---------------- | ------------------------------------ |
| 네비게이션       | navigate, page-reload, tabs-create   |
| 인터랙션         | click-element, fill-form, drag-drop  |
| 데이터 추출      | read-page, page-content, xpath-query |
| 환경 에뮬레이션  | emulate-device, geolocation          |
| 스토리지         | cookies, storage                     |
| 디버깅           | console-capture, network, inspect    |
| 병렬 워크플로우  | worker-create/delete/list, batch-*   |

### 주목할 만한 도구들

**read_page**: 세 가지 모드를 지원한다.
"ax"(접근성 트리, ref_N ID 포함),
"dom"(컴팩트 DOM, 토큰 5-10배 절감),
"css"(CSS 진단, 프레임워크 감지).
하나의 도구가 AI의 "눈" 역할을 한다.

**click_element**: find + get-coords + click을 단일
호출로 합친 복합 도구. 자연어 쿼리로 DOM 요소를 찾고,
후보를 점수화하고, 뷰포트로 스크롤한 뒤 클릭한다.

**batch_execute**: 여러 탭에서 JavaScript를 병렬 실행.
기본 동시성 10. "Phase 2 에이전트 스폰을 ~109초에서
~0초로 줄인다"고 설명한다.

**batch_paginate**: 4가지 전략(키보드, 클릭, URL 병렬
탭, 스크롤)으로 단일 호출 페이지네이션 추출.

**navigate**: `smartGoto()`를 내장한다. 20개 이상의
인증 도메인(Google, Microsoft, Okta 등)에 대해
`framenavigated` 이벤트로 인증 리다이렉트를 빠르게
감지한다.

**lightweight_scroll**: 스크린샷 오버헤드 없는 고성능
스크롤. 20개 이상 탭에서 "185초(타임아웃)에서 5ms 미만"
으로 개선.

## 배포 옵션

```bash
# 설치
npx openchrome-mcp setup

# 서버 모드
openchrome serve --server-mode

# 헤드리스 (CI/CD용)
openchrome serve --headless-shell

# Docker
docker run openchrome-mcp
```

Docker 이미지는 Node.js 20-slim 기반이다. Chromium과 필수
시스템 라이브러리를 설치하고, 비루트 사용자(openchrome)로
실행한다.

## 프로젝트 규모

| 항목           | 수량     |
| -------------- | -------- |
| 소스 코드      | ~107파일 |
| CLI            | 5파일    |
| Chrome 확장    | ~15파일  |
| 네이티브 호스트 | 4파일    |
| 테스트         | ~70+파일 |
| 총계           | ~220+파일 |

기술 스택: TypeScript(ES2022, strict), Puppeteer Core,
Webpack, Jest, Docker. 3개의 tsconfig(메인, CLI, 테스트)로
빌드를 분리한다.

CI: GitHub Actions에서 3 OS(Ubuntu, macOS, Windows) x
3 Node.js(18, 20, 22) = 9개 조합 매트릭스로 테스트한다.

## 인사이트

### 1. MCP가 브라우저 자동화의 게임 체인저다

Selenium, Playwright 등 기존 도구는 "프로그래머가 스크립트를
작성하는" 모델이었다. OpenChrome은 MCP를 통해 "AI가 도구를
호출하는" 모델로 전환한다. 47개 도구가 JSON-RPC로 노출되므로
어떤 MCP 호환 AI 에이전트든 브라우저를 제어할 수 있다. 이것은
단순한 래퍼가 아니라 패러다임 전환이다.

### 2. 힌트 엔진이 진짜 혁신이다

대부분의 브라우저 자동화 MCP는 "AI에게 페이지를 보여주고
판단하게 하는" 방식이다. OpenChrome은 6계층 힌트 시스템과
패턴 학습기를 통해 AI가 "추측하지 않아도 되게" 만든다.
LLM 호출을 80% 줄인다는 것은 비용과 지연시간 모두에서
압도적 우위를 의미한다. 특히 에스컬레이션과 자연 감쇠
메커니즘은 장기 세션에서의 안정성을 보장한다.

### 3. 하이브리드 상태 관리는 분산 시스템의 지혜다

오케스트레이션 엔진의 "인메모리 + 파일 기반 write-behind"
패턴은 분산 시스템에서 검증된 접근법이다. 정합성이 필요한
카운터는 메모리에, 가시성이 필요한 상태는 파일에 두는 분리가
깔끔하다. 프로미스 기반 뮤텍스로 Node.js의 단일 스레드
특성을 최대한 활용하면서도 동시성 문제를 해결한다.

### 4. DOM 직렬화 전략이 토큰 경제학을 바꾼다

GPT-4 기준 1K 토큰당 약 $0.03이다. 웹 페이지 하나의 전체
DOM은 수만 토큰이 될 수 있다. OpenChrome의 DOM 직렬화는
불필요한 요소를 제거하고 인터랙티브 요소를 마킹해 5-10배
토큰 절감을 달성한다. 대규모 자동화에서 이 차이는 운영
비용에 직결된다.

### 5. 보안은 "모든 경로의 관문"이어야 한다

`assertDomainAllowed()`가 모든 `getPage()` 호출을
보호한다는 설계가 중요하다. 개별 도구마다 보안 체크를
넣는 대신, 페이지 접근이라는 단일 병목점에서 차단한다.
이것은 보안 누락을 구조적으로 방지하는 패턴이다.

### 6. 커넥션 풀의 "Fire-and-Forget" 릴리즈

페이지 반환 시 호출자를 차단하지 않는 설계다.
about:blank 이동과 쿠키/스토리지 클리어를 백그라운드에서
처리한다. 이로써 도구 실행의 체감 지연시간이 줄어든다.
풀 사이즈를 기본 0으로 두고 필요 시 확장하는 보수적
기본값도 안정성을 우선하는 설계 철학을 보여준다.

### 7. 세션의 자기 치유 능력

세션 매니저가 about:blank 고스트 탭(Site Isolation의
부작용)을 자동 감지/제거하고, 죽은 타겟을 URL 매칭으로
복구하며, 커넥션 에러 시 자동 재연결을 시도한다. 이런
자기 치유 패턴은 장시간 무인 자동화에서 결정적 차이를
만든다.

### 8. 확장 프로그램은 "경량 모드"다

Chrome 확장(extension/)은 메인 서버의 47개 도구 중 9개만
구현한다. 서비스 워커 기반으로 네이티브 메시징 호스트와
통신한다. 풀 서버 없이 가벼운 자동화가 필요한 사용자를
위한 진입점이다.

### 9. 테스트 전략이 성숙하다

단위 테스트, 통합 테스트, E2E 테스트, 벤치마크, 스트레스
테스트까지 5단계 테스트 피라미드를 갖추고 있다. 특히
스트레스 테스트(concurrent-updates, error-recovery,
large-data)는 프로덕션 안정성에 대한 진지한 투자를 보여준다.
Jest 설정을 일반과 CI로 분리한 것도 실용적이다.

### 10. 하이브리드 브라우저 라우팅은 미래 지향적이다

Chrome만 쓰는 대신 Lightpanda 같은 경량 브라우저를
기본으로 쓰고, 시각 도구가 필요할 때만 Chrome으로
에스컬레이션하는 전략이다. 회로 차단기 패턴으로 장애를
격리하고, 양방향 쿠키 동기화로 세션 일관성을 유지한다.
브라우저 백엔드가 교체 가능한 설계는 향후 더 효율적인
엔진이 등장했을 때 즉시 통합할 수 있는 확장성을 제공한다.

### 11. 플랜 캐싱이 "학습하는 자동화"를 만든다

반복적인 작업을 플랜으로 영속화하고, URL 패턴과 키워드로
매칭해 재사용한다. 성공/실패 통계를 롤링으로 추적하며
신뢰도가 낮은 플랜은 자동 폐기된다. 도메인 메모리와
결합하면 "같은 사이트에서 같은 실수를 두 번 하지 않는"
시스템이 된다. 이것은 단순 자동화를 넘어 적응형 자동화에
가깝다.

### 12. 설정 복구는 "방어적 인프라"의 교과서다

설정 파일 하나의 손상이 전체 시스템을 멈출 수 있다.
OpenChrome은 다중 전략 복구, 파일 감시 자동 복구, 10개
백업 유지, 세션별 격리, 24시간 오래된 세션 자동 정리까지
구현한다. 이 수준의 방어적 프로그래밍은 프로덕션 환경에서
검증된 교훈의 결과로 보인다.

### 13. 경쟁 우위의 본질은 "AI-Native" 설계다

OpenChrome은 처음부터 AI 에이전트가 사용하는 것을 전제로
설계되었다. DOM 직렬화의 ★ 마커, 힌트 엔진의 LLM 호출
최적화, Ralph Loop 기반 워커 프롬프트, 복합 도구(find +
click을 click_element 하나로), 도메인 메모리의 신뢰도 기반
지식 관리까지 모든 것이 "AI가 더 적은 비용으로 더 잘
작동하게" 만드는 데 집중한다. 이것이 Playwright나 Selenium
위에 MCP 래퍼를 얹는 것과 근본적으로 다른 점이다.

### 14. CDP 클라이언트의 프로미스 병합이 영리하다

동시에 여러 곳에서 CDP 연결을 요청하면 첫 번째 요청의
프로미스를 공유해 중복 연결을 방지한다. 하트비트
모니터링(15초 간격), TCP RST 감지, 절전/복귀 감지까지
갖추고 있다. 쿠키 관리에 5분 TTL 캐싱을 적용하고,
타겟-to-페이지 인덱스를 O(1)로 유지한다. 이 수준의
연결 관리는 안정적인 장기 세션의 기반이다.

### 15. 스크린샷 스케줄러의 적응형 열화

`AdaptiveScreenshot`은 같은 탭에서 반복 스크린샷을
감지(50px 허용 오차, 30초 윈도우)하면 annotated 모드,
text_only 모드로 자동 열화한다. 동시 스크린샷도 5개로
제한해 "20개 동시 스크린샷을 4000ms에서 ~800ms"로 줄인다.
"불필요한 비용을 시스템이 알아서 줄여주는" 설계다.
