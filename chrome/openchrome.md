# OpenChrome

오픈소스 브라우저 자동화 MCP 서버.
AI 에이전트가 실제 Chrome 인스턴스를 제어할 수 있게 한다.

<https://github.com/shaun0927/openchrome>

## 핵심 가치

**"Smart. Fast. Parallel."**

기존 브라우저 자동화의 세 가지 병목을 정면으로 해결한다:

| 문제                   | 기존 방식           | OpenChrome          |
| ---------------------- | ------------------- | ------------------- |
| 속도                   | 5개 사이트 ~250초   | ~3초                |
| 메모리                 | ~2.5GB              | ~300MB              |
| LLM 호출              | ~100회              | ~20회               |

단일 Chrome 프로세스에서 20개 이상의 병렬 세션을 실행하면서
메모리를 300MB 수준으로 유지한다.

## 아키텍처

```
┌─────────────────────────────────────────────┐
│                MCP Server                   │
│           (JSON-RPC 2.0 / stdio)            │
├─────────────────────────────────────────────┤
│  Session Manager                            │
│  ├── Worker (격리된 브라우저 컨텍스트)       │
│  │   └── Target (페이지/탭, 워커당 최대 5)  │
│  ├── CDP Connection Pool                    │
│  └── Chrome Pool (origin-aware)             │
├─────────────────────────────────────────────┤
│  47개 도구  │  힌트 엔진  │  오케스트레이션  │
├─────────────────────────────────────────────┤
│  Chrome DevTools Protocol (CDP)             │
│  ├── client.ts (CDP 클라이언트)             │
│  ├── connection-pool.ts (커넥션 풀링)       │
│  └── screenshot-scheduler.ts                │
├─────────────────────────────────────────────┤
│  Chrome (Puppeteer Core)                    │
└─────────────────────────────────────────────┘
```

### 세션 계층 구조

```
SessionManager
└── Session (기본 TTL: 30분)
    ├── Worker (기본 + 커스텀 워커)
    │   └── Target (페이지/탭)
    └── Browser Context (쿠키/스토리지 격리)
```

세션 매니저의 설계가 인상적이다. 메모리 압박 시 가용 RAM이
500MB 이하로 떨어지면 공격적으로 세션을 정리한다. 죽은 타겟
ID를 URL 매칭으로 라이브 타겟에 재매핑하는 복구 메커니즘도
갖추고 있다. OAuth 리다이렉트 같은 크로스오리진 네비게이션
에서도 세션이 유지된다.

## 핵심 모듈 분석

### 1. 힌트 엔진 (src/hints/)

LLM 호출을 80% 줄이는 핵심 차별화 요소다.

6계층 규칙 시스템:

| 우선순위 | 규칙                 | 역할                   |
| -------- | -------------------- | ---------------------- |
| 90       | 설정 힌트            | 초기 설정 가이드       |
| 100-108  | 오류 복구            | 실패 시 자동 복구      |
| 190-192  | 페이지네이션 감지    | 다음 페이지 자동 탐지  |
| 200-203  | 복합 제안            | 다단계 작업 축약       |
| 245-252  | 반복 감지            | 루프 패턴 식별         |
| 300-304  | 시퀀스 감지          | 작업 흐름 예측         |
| 350      | 학습된 규칙          | 패턴 학습 결과 적용    |
| 400-403  | 성공 힌트            | 완료 시 다음 단계 제안 |

**심각도 에스컬레이션**: 같은 규칙이 반복 발화되면 심각도가
자동 상승한다.

- 1-2회: info (원본 텍스트)
- 3-4회: warning (경고 접두사)
- 5회 이상: critical (액션 히스토리 포함)

10회 연속 미스 시 발화 카운트가 0으로 리셋되어 오래된
에스컬레이션을 자연 감쇠시킨다.

**패턴 학습기**(pattern-learner.ts)가 실행 중 패턴을 학습해
학습된 규칙으로 피드백하는 적응형 구조다. JSONL 기반 비동기
버퍼 로깅(200ms 플러시)으로 메인 스레드를 차단하지 않는다.

### 2. DOM 직렬화 (src/dom/)

토큰 사용량을 5-10배 줄이는 또 다른 핵심이다.

CDP DOM 트리를 컴팩트 텍스트로 변환한다. script, style 등
불필요한 요소를 완전히 건너뛰고, id, name, aria-label 등
관련 속성만 보존한다.

출력 형식: `[backendNodeId]<tagName attrs/>textContent ★`

인터랙티브 요소(input, button, select 또는 ARIA 역할)에
★ 마커를 붙여 AI가 즉시 식별할 수 있게 한다.
interactiveOnly, pierceIframes, maxDepth, maxOutputChars
옵션으로 출력을 세밀하게 제어할 수 있다.

### 3. 오케스트레이션 엔진 (src/orchestration/)

병렬 워크플로우의 뇌다.

- **plan-executor.ts**: 플랜 실행
- **plan-registry.ts**: 플랜 등록/관리
- **state-manager.ts**: 상태 추적
- **workflow-engine.ts**: 핵심 엔진

**하이브리드 상태 관리**: 인메모리 상태를 정합성의 단일
진실 원천(source of truth)으로 사용하고, 파일 기반 영속성은
디버깅용 보조 수단으로만 활용한다. 프로미스 기반 뮤텍스
(`completionLock`)로 동시 완료 시 lost update를 방지한다.

**회로 차단기**: 워커별 절대 타임아웃(기본 60초), 전역
워크플로우 타임아웃(기본 300초), 데이터 해시 기반 정체 감지
(동일 데이터 5회 연속 시 강제 완료)를 갖추고 있다.

**Ralph Loop 알고리즘**: 워커 프롬프트에
assess -> decide -> execute -> update 루프를 삽입해
에이전트의 자율 실행을 구조화한다.

### 4. CDP 커넥션 풀 (src/cdp/)

페이지 획득 시간을 100ms 이하로 끌어내리는 인프라다.

사전 할당된 Puppeteer 페이지를 관리한다. 반환된 페이지는
about:blank로 이동 후 쿠키/스토리지를 CDP로 클리어한 뒤
풀에 복귀한다. 30초 간격 유지보수 타이머로 유휴 페이지를
정리하면서 최소 풀 사이즈를 보장한다.

"Fire-and-forget" 릴리즈 패턴으로 호출자를 차단하지 않는다.

### 5. 보안 계층 (src/security/)

- **domain-guard.ts**: 중앙화된 도메인 차단 목록.
  `assertDomainAllowed()`가 모든 getPage() 호출을 보호한다.
- **audit-logger.ts**: 모든 도구 호출에 타이밍 메타데이터를
  기록하는 감사 로거.

## 47개 도구

7개 카테고리로 분류된다:

| 카테고리         | 도구 예시                            |
| ---------------- | ------------------------------------ |
| 네비게이션       | navigate, page-reload, tabs-create   |
| 인터랙션         | click-element, fill-form, drag-drop  |
| 데이터 추출      | read-page, page-content, xpath-query |
| 환경 에뮬레이션  | emulate-device, geolocation          |
| 스토리지         | cookies, storage                     |
| 디버깅           | console-capture, network, inspect    |
| 병렬 워크플로우  | worker-create/delete/list, batch-*   |

## 배포 옵션

```bash
# 설치
npx openchrome-mcp setup

# 서버 모드
openchrome serve --server-mode

# 헤드리스 (CI/CD용)
openchrome serve --headless-shell

# Docker
docker run openchrome-mcp
```

Docker 이미지는 Node.js 20-slim 기반이다. Chromium과 필수
시스템 라이브러리를 설치하고, 비루트 사용자(openchrome)로
실행한다.

## 프로젝트 규모

| 항목           | 수량     |
| -------------- | -------- |
| 소스 코드      | ~107파일 |
| CLI            | 5파일    |
| Chrome 확장    | ~15파일  |
| 네이티브 호스트 | 4파일    |
| 테스트         | ~70+파일 |
| 총계           | ~220+파일 |

기술 스택: TypeScript, Puppeteer Core, Webpack, Jest,
Docker. 3개의 tsconfig(메인, CLI, 테스트)로 빌드를 분리한다.

## 인사이트

### 1. MCP가 브라우저 자동화의 게임 체인저다

Selenium, Playwright 등 기존 도구는 "프로그래머가 스크립트를
작성하는" 모델이었다. OpenChrome은 MCP를 통해 "AI가 도구를
호출하는" 모델로 전환한다. 47개 도구가 JSON-RPC로 노출되므로
어떤 MCP 호환 AI 에이전트든 브라우저를 제어할 수 있다. 이것은
단순한 래퍼가 아니라 패러다임 전환이다.

### 2. 힌트 엔진이 진짜 혁신이다

대부분의 브라우저 자동화 MCP는 "AI에게 페이지를 보여주고
판단하게 하는" 방식이다. OpenChrome은 6계층 힌트 시스템과
패턴 학습기를 통해 AI가 "추측하지 않아도 되게" 만든다.
LLM 호출을 80% 줄인다는 것은 비용과 지연시간 모두에서
압도적 우위를 의미한다. 특히 에스컬레이션과 자연 감쇠
메커니즘은 장기 세션에서의 안정성을 보장한다.

### 3. 하이브리드 상태 관리는 분산 시스템의 지혜다

오케스트레이션 엔진의 "인메모리 + 파일 기반 write-behind"
패턴은 분산 시스템에서 검증된 접근법이다. 정합성이 필요한
카운터는 메모리에, 가시성이 필요한 상태는 파일에 두는 분리가
깔끔하다. 프로미스 기반 뮤텍스로 Node.js의 단일 스레드
특성을 최대한 활용하면서도 동시성 문제를 해결한다.

### 4. DOM 직렬화 전략이 토큰 경제학을 바꾼다

GPT-4 기준 1K 토큰당 약 $0.03이다. 웹 페이지 하나의 전체
DOM은 수만 토큰이 될 수 있다. OpenChrome의 DOM 직렬화는
불필요한 요소를 제거하고 인터랙티브 요소를 마킹해 5-10배
토큰 절감을 달성한다. 대규모 자동화에서 이 차이는 운영
비용에 직결된다.

### 5. 보안은 "모든 경로의 관문"이어야 한다

`assertDomainAllowed()`가 모든 `getPage()` 호출을
보호한다는 설계가 중요하다. 개별 도구마다 보안 체크를
넣는 대신, 페이지 접근이라는 단일 병목점에서 차단한다.
이것은 보안 누락을 구조적으로 방지하는 패턴이다.

### 6. 커넥션 풀의 "Fire-and-Forget" 릴리즈

페이지 반환 시 호출자를 차단하지 않는 설계다.
about:blank 이동과 쿠키/스토리지 클리어를 백그라운드에서
처리한다. 이로써 도구 실행의 체감 지연시간이 줄어든다.
풀 사이즈를 기본 0으로 두고 필요 시 확장하는 보수적
기본값도 안정성을 우선하는 설계 철학을 보여준다.

### 7. 세션의 자기 치유 능력

세션 매니저가 about:blank 고스트 탭(Site Isolation의
부작용)을 자동 감지/제거하고, 죽은 타겟을 URL 매칭으로
복구하며, 커넥션 에러 시 자동 재연결을 시도한다. 이런
자기 치유 패턴은 장시간 무인 자동화에서 결정적 차이를
만든다.

### 8. 확장 프로그램은 "경량 모드"다

Chrome 확장(extension/)은 메인 서버의 47개 도구 중 9개만
구현한다. 서비스 워커 기반으로 네이티브 메시징 호스트와
통신한다. 풀 서버 없이 가벼운 자동화가 필요한 사용자를
위한 진입점이다.

### 9. 테스트 전략이 성숙하다

단위 테스트, 통합 테스트, E2E 테스트, 벤치마크, 스트레스
테스트까지 5단계 테스트 피라미드를 갖추고 있다. 특히
스트레스 테스트(concurrent-updates, error-recovery,
large-data)는 프로덕션 안정성에 대한 진지한 투자를 보여준다.
Jest 설정을 일반과 CI로 분리한 것도 실용적이다.

### 10. 경쟁 우위의 본질은 "AI-Native" 설계다

OpenChrome은 처음부터 AI 에이전트가 사용하는 것을 전제로
설계되었다. DOM 직렬화의 ★ 마커, 힌트 엔진의 LLM 호출
최적화, Ralph Loop 기반 워커 프롬프트 등 모든 것이 "AI가
더 적은 비용으로 더 잘 작동하게" 만드는 데 집중한다.
이것이 Playwright나 Selenium 위에 MCP 래퍼를 얹는 것과
근본적으로 다른 점이다.
